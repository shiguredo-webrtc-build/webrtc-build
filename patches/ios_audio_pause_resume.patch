diff --git a/sdk/BUILD.gn b/sdk/BUILD.gn
index 7b8a024..e2f6c7a 100644
--- a/sdk/BUILD.gn
+++ b/sdk/BUILD.gn
@@ -172,6 +172,7 @@ if (is_ios || is_mac) {
       sources += [
         "objc/helpers/UIDevice+RTCDevice.h",
         "objc/helpers/UIDevice+RTCDevice.mm",
+        "objc/components/audio/RTCAudioDeviceModule.mm",
       ]
 
       if (target_platform != "tvos") {
@@ -185,7 +186,7 @@ if (is_ios || is_mac) {
     }
   }
 
-  rtc_library("core_audio_helpers_objc") {
+rtc_library("core_audio_helpers_objc") {
     sources = [
       "objc/helpers/AudioTimeStamp+Nanoseconds.h",
       "objc/helpers/AudioTimeStamp+Nanoseconds.mm",
@@ -1366,6 +1367,7 @@ if (is_ios || is_mac) {
           "objc/base/RTCVideoRenderer.h",
           "objc/base/RTCYUVPlanarBuffer.h",
           "objc/components/audio/RTCAudioDevice.h",
+          "objc/components/audio/RTCAudioDeviceModule.h",
           "objc/components/audio/RTCAudioSession.h",
           "objc/components/audio/RTCAudioSessionConfiguration.h",
           "objc/components/capturer/RTCCameraVideoCapturer.h",
diff --git a/sdk/objc/components/audio/RTCAudioDeviceModule.h b/sdk/objc/components/audio/RTCAudioDeviceModule.h
new file mode 100644
index 0000000..1937cd0
--- /dev/null
+++ b/sdk/objc/components/audio/RTCAudioDeviceModule.h
@@ -0,0 +1,24 @@
+// 音声の録音ポーズ・復帰用の公開 API を提供するためのモジュールです
+
+#import <Foundation/Foundation.h>
+
+#import "sdk/objc/base/RTCMacros.h"
+
+RTC_OBJC_EXPORT
+@interface RTC_OBJC_TYPE(RTCAudioDeviceModule) : NSObject
+
+// 現状は単一の ADM のみを扱う想定として、シングルトンインスタンスを取得する
++ (instancetype)sharedInstance;
+
+// 登録中の AudioDeviceModuleIOS を弱参照で保持し、録音制御を委譲する
+//
+// 引数の型は AudioDeviceModuleIOS* を想定しているが、C++ 側定義の型であり
+// この ObjC 公開ヘッダでの露出はビルドエラーとなるため void* としている
+// 実装側で AudioDeviceModuleIOS* に static_cast する
+- (void)setAudioDeviceModule:(void *)adm;
+- (void)clearAudioDeviceModule:(void *)adm;
+
+- (BOOL)pauseRecording;
+- (BOOL)resumeRecording;
+
+@end
diff --git a/sdk/objc/components/audio/RTCAudioDeviceModule.mm b/sdk/objc/components/audio/RTCAudioDeviceModule.mm
new file mode 100644
index 0000000..b6b9f29
--- /dev/null
+++ b/sdk/objc/components/audio/RTCAudioDeviceModule.mm
@@ -0,0 +1,57 @@
+// 音声の録音ポーズ・復帰用の公開 API を提供するためのモジュールです
+
+#import "RTCAudioDeviceModule.h"
+
+#include "sdk/objc/native/src/audio/audio_device_module_ios.h"
+
+@interface RTC_OBJC_TYPE(RTCAudioDeviceModule) () {
+  webrtc::ios_adm::AudioDeviceModuleIOS* _adm;
+}
+@end
+
+@implementation RTC_OBJC_TYPE(RTCAudioDeviceModule)
+
++ (instancetype)sharedInstance {
+  static RTC_OBJC_TYPE(RTCAudioDeviceModule) *instance = nil;
+  static dispatch_once_t onceToken;
+  dispatch_once(&onceToken, ^{
+    instance = [[self alloc] init];
+  });
+  return instance;
+}
+
+- (void)setAudioDeviceModule:(void *)adm_void {
+  webrtc::ios_adm::AudioDeviceModuleIOS* adm =
+      static_cast<webrtc::ios_adm::AudioDeviceModuleIOS*>(adm_void);
+  if (adm) {
+    _adm = adm;
+  } else {
+    _adm = nullptr;
+  }
+}
+
+- (void)clearAudioDeviceModule:(void *)adm_void {
+  webrtc::ios_adm::AudioDeviceModuleIOS* adm =
+      static_cast<webrtc::ios_adm::AudioDeviceModuleIOS*>(adm_void);
+  if (_adm == adm) {
+    _adm = nullptr;
+  }
+}
+
+- (BOOL)pauseRecording {
+  webrtc::ios_adm::AudioDeviceModuleIOS* ptr = _adm;
+  if (!ptr) {
+    return NO;
+  }
+  return ptr->PauseRecording() == 0;
+}
+
+- (BOOL)resumeRecording {
+  webrtc::ios_adm::AudioDeviceModuleIOS* ptr = _adm;
+  if (!ptr) {
+    return NO;
+  }
+  return ptr->ResumeRecording() == 0;
+}
+
+@end
diff --git a/sdk/objc/native/src/audio/audio_device_ios.h b/sdk/objc/native/src/audio/audio_device_ios.h
index d1788a3..b3d2b32 100644
--- a/sdk/objc/native/src/audio/audio_device_ios.h
+++ b/sdk/objc/native/src/audio/audio_device_ios.h
@@ -80,6 +80,8 @@ class AudioDeviceIOS : public AudioDeviceGeneric,
   bool Playing() const override;
 
   int32_t StartRecording() override;
+  int32_t PauseRecording();
+  int32_t ResumeRecording();
   int32_t StopRecording() override;
   bool Recording() const override;
 
@@ -292,6 +294,9 @@ class AudioDeviceIOS : public AudioDeviceGeneric,
   // Set to 1 when playout is active and 0 otherwise.
   std::atomic<int> playing_;
 
+  // Set to true when recording has been paused explicitly.
+  bool paused_recording_;
+
   // Set to true after successful call to Init(), false otherwise.
   bool initialized_ RTC_GUARDED_BY(thread_);
 
diff --git a/sdk/objc/native/src/audio/audio_device_ios.mm b/sdk/objc/native/src/audio/audio_device_ios.mm
index 021f08a..df215c1 100644
--- a/sdk/objc/native/src/audio/audio_device_ios.mm
+++ b/sdk/objc/native/src/audio/audio_device_ios.mm
@@ -110,6 +110,7 @@ static void LogDeviceInfo() {
       audio_unit_(nullptr),
       recording_(0),
       playing_(0),
+      paused_recording_(false),
       initialized_(false),
       audio_is_initialized_(false),
       is_interrupted_(false),
@@ -302,6 +303,10 @@ static void LogDeviceInfo() {
   LOGI() << "StartRecording";
   RTC_DCHECK_RUN_ON(thread_);
   RTC_DCHECK(audio_is_initialized_);
+  // 録音ポーズ中であれば ResumeRecording() にフォールスルーする
+  if (paused_recording_) {
+    return ResumeRecording();
+  }
   RTC_DCHECK(!recording_.load());
   RTC_DCHECK(audio_unit_);
   if (!audio_is_initialized_) {
@@ -330,9 +335,15 @@ static void LogDeviceInfo() {
 int32_t AudioDeviceIOS::StopRecording() {
   LOGI() << "StopRecording";
   RTC_DCHECK_RUN_ON(thread_);
-  if (!audio_is_initialized_ || !recording_.load()) {
+  if (!audio_is_initialized_)
+    return 0;
+  // 録音ポーズ中でも解放処理を実行するためのチェック
+  // 録音フラグが立っていない、かつ、録音ポーズ中でない -> 解放済みである、としてリターン
+  if (!recording_.load() && !paused_recording_) {
     return 0;
   }
+  // 実際の状態に関わらず録音ポーズフラグも解除しておく
+  paused_recording_ = false;
   if (!playing_.load()) {
     ShutdownPlayOrRecord();
   }
@@ -340,6 +351,46 @@ static void LogDeviceInfo() {
   return 0;
 }
 
+int32_t AudioDeviceIOS::PauseRecording() {
+  LOGI() << "PauseRecording";
+  RTC_DCHECK_RUN_ON(thread_);
+  if (paused_recording_) {
+    return 0;
+  }
+  if (!audio_is_initialized_ || !recording_.load()) {
+    return 0;
+  }
+  recording_.store(0, std::memory_order_release);
+  paused_recording_ = true;
+  return 0;
+}
+
+int32_t AudioDeviceIOS::ResumeRecording() {
+  LOGI() << "ResumeRecording";
+  RTC_DCHECK_RUN_ON(thread_);
+  if (!paused_recording_) {
+    return 0;
+  }
+  // 通常の pauseRecording() から来る場合は不要であるはずだが
+  // 初期化状態をチェックして必要であれば InitRecording() を実行
+  if (!audio_is_initialized_) {
+    if (InitRecording() != 0) {
+      RTC_LOG(LS_ERROR) << "InitRecording failed during ResumeRecording";
+      paused_recording_ = false;
+      recording_.store(0, std::memory_order_release);
+      return -1;
+    }
+  }
+  paused_recording_ = false;
+  int32_t result = StartRecording();
+  if (result != 0) {
+    // Start に失敗したら再度 pause 状態に戻す
+    paused_recording_ = true;
+    recording_.store(0, std::memory_order_release);
+  }
+  return result;
+}
+
 bool AudioDeviceIOS::Recording() const {
   return recording_.load();
 }
diff --git a/sdk/objc/native/src/audio/audio_device_module_ios.h b/sdk/objc/native/src/audio/audio_device_module_ios.h
index 5ff5062..987deb8 100644
--- a/sdk/objc/native/src/audio/audio_device_module_ios.h
+++ b/sdk/objc/native/src/audio/audio_device_module_ios.h
@@ -76,6 +76,8 @@ class AudioDeviceModuleIOS : public AudioDeviceModule {
   int32_t StopPlayout() override;
   bool Playing() const override;
   int32_t StartRecording() override;
+  int32_t PauseRecording();
+  int32_t ResumeRecording();
   int32_t StopRecording() override;
   bool Recording() const override;
 
diff --git a/sdk/objc/native/src/audio/audio_device_module_ios.mm b/sdk/objc/native/src/audio/audio_device_module_ios.mm
index e2ea360..137277a 100644
--- a/sdk/objc/native/src/audio/audio_device_module_ios.mm
+++ b/sdk/objc/native/src/audio/audio_device_module_ios.mm
@@ -18,6 +18,7 @@
 #include "rtc_base/logging.h"
 #include "rtc_base/ref_count.h"
 #include "system_wrappers/include/metrics.h"
+#include "sdk/objc/components/audio/RTCAudioDeviceModule.h"
 
 #if defined(WEBRTC_IOS)
 #include "audio_device_ios.h"
@@ -53,6 +54,10 @@
       error_handler_(error_handler) {
   RTC_LOG(LS_INFO) << "current platform is IOS";
   RTC_LOG(LS_INFO) << "iPhone Audio APIs will be utilized.";
+  // RTCAudioDeviceModule のシングルトンインスタンスにポインタ参照をセット
+  RTC_OBJC_TYPE(RTCAudioDeviceModule)* adm_module =
+      [RTC_OBJC_TYPE(RTCAudioDeviceModule) sharedInstance];
+  [adm_module setAudioDeviceModule:this];
 }
 
 int32_t AudioDeviceModuleIOS::AttachAudioBuffer() {
@@ -63,6 +68,10 @@
 
 AudioDeviceModuleIOS::~AudioDeviceModuleIOS() {
   RTC_DLOG(LS_INFO) << __FUNCTION__;
+  // RTCAudioDeviceModule のシングルトンインスタンスで保持しているポインタ参照を破棄する
+  RTC_OBJC_TYPE(RTCAudioDeviceModule)* adm_module =
+      [RTC_OBJC_TYPE(RTCAudioDeviceModule) sharedInstance];
+  [adm_module clearAudioDeviceModule:this];
 }
 
 void AudioDeviceModuleIOS::ReportError(ADMError error) const {
@@ -652,6 +661,30 @@
   return result;
 }
 
+int32_t AudioDeviceModuleIOS::PauseRecording() {
+  RTC_DLOG(LS_INFO) << __FUNCTION__;
+  CHECKinitialized_();
+  int32_t result = audio_device_->PauseRecording();
+  audio_device_buffer_.get()->StopRecording();
+  if (result < 0) {
+    ReportError(kRecordingFailed);
+  }
+  RTC_DLOG(LS_INFO) << "output: " << result;
+  return result;
+}
+
+int32_t AudioDeviceModuleIOS::ResumeRecording() {
+  RTC_DLOG(LS_INFO) << __FUNCTION__;
+  CHECKinitialized_();
+  audio_device_buffer_.get()->StartRecording();
+  int32_t result = audio_device_->ResumeRecording();
+  if (result < 0) {
+    ReportError(kRecordingFailed);
+  }
+  RTC_DLOG(LS_INFO) << "output: " << result;
+  return result;
+}
+
 int32_t AudioDeviceModuleIOS::StopRecording() {
   RTC_DLOG(LS_INFO) << __FUNCTION__;
   CHECKinitialized_();
