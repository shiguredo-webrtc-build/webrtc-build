diff --git a/sdk/BUILD.gn b/sdk/BUILD.gn
index 7b8a024..e2f6c7a 100644
--- a/sdk/BUILD.gn
+++ b/sdk/BUILD.gn
@@ -172,6 +172,7 @@ if (is_ios || is_mac) {
       sources += [
         "objc/helpers/UIDevice+RTCDevice.h",
         "objc/helpers/UIDevice+RTCDevice.mm",
+        "objc/components/audio/RTCAudioDeviceModule.mm",
       ]
 
       if (target_platform != "tvos") {
@@ -185,7 +186,7 @@ if (is_ios || is_mac) {
     }
   }
 
-  rtc_library("core_audio_helpers_objc") {
+rtc_library("core_audio_helpers_objc") {
     sources = [
       "objc/helpers/AudioTimeStamp+Nanoseconds.h",
       "objc/helpers/AudioTimeStamp+Nanoseconds.mm",
@@ -1366,6 +1367,7 @@ if (is_ios || is_mac) {
           "objc/base/RTCVideoRenderer.h",
           "objc/base/RTCYUVPlanarBuffer.h",
           "objc/components/audio/RTCAudioDevice.h",
+          "objc/components/audio/RTCAudioDeviceModule.h",
           "objc/components/audio/RTCAudioSession.h",
           "objc/components/audio/RTCAudioSessionConfiguration.h",
           "objc/components/capturer/RTCCameraVideoCapturer.h",
diff --git a/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h b/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
index 8287bcf..82a7866 100644
--- a/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
+++ b/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
@@ -11,6 +11,7 @@
 #import <Foundation/Foundation.h>
 
 #import "sdk/objc/base/RTCMacros.h"
+#import "sdk/objc/components/audio/RTCAudioDeviceModule.h"
 
 NS_ASSUME_NONNULL_BEGIN
 
@@ -34,6 +35,7 @@ NS_ASSUME_NONNULL_BEGIN
 (RTCSSLCertificateVerifier);
 @protocol RTC_OBJC_TYPE
 (RTCAudioDevice);
+@class RTC_OBJC_TYPE(RTCAudioDeviceModule);
 
 typedef NS_ENUM(NSInteger, RTCProxyType);
 
@@ -52,7 +54,7 @@ RTC_OBJC_EXPORT
                                decoderFactory;
 
 /* Initialize object with injectable video encoder/decoder factories and
- * injectable ADM */
+ * injectable ADM (RTCAudioDevice) */
 - (instancetype)
     initWithEncoderFactory:
         (nullable id<RTC_OBJC_TYPE(RTCVideoEncoderFactory)>)encoderFactory
@@ -61,6 +63,27 @@ RTC_OBJC_EXPORT
                audioDevice:
                    (nullable id<RTC_OBJC_TYPE(RTCAudioDevice)>)audioDevice;
 
+/* Initialize object with injectable video encoder/decoder factories and
+ * RTCAudioDeviceModule (pause/resume 用) */
+- (instancetype)
+    initWithEncoderFactory:
+        (nullable id<RTC_OBJC_TYPE(RTCVideoEncoderFactory)>)encoderFactory
+            decoderFactory:(nullable id<RTC_OBJC_TYPE(RTCVideoDecoderFactory)>)
+                               decoderFactory
+          audioDeviceModule:
+              (nullable RTC_OBJC_TYPE(RTCAudioDeviceModule)*)audioDeviceModule;
+
+/* Initialize object with injectable video encoder/decoder factories and
+ * both RTCAudioDevice (objC) and RTCAudioDeviceModule (pause/resume 用) */
+- (instancetype)
+    initWithEncoderFactory:
+        (nullable id<RTC_OBJC_TYPE(RTCVideoEncoderFactory)>)encoderFactory
+            decoderFactory:(nullable id<RTC_OBJC_TYPE(RTCVideoDecoderFactory)>)
+                               decoderFactory
+               audioDevice:(nullable id<RTC_OBJC_TYPE(RTCAudioDevice)>)audioDevice
+          audioDeviceModule:
+              (nullable RTC_OBJC_TYPE(RTCAudioDeviceModule)*)audioDeviceModule;
+
 /**
  * Valid kind values are kRTCMediaStreamTrackKindAudio and
  * kRTCMediaStreamTrackKindVideo.
diff --git a/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm b/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
index 233cf25..1e2c0fa 100644
--- a/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
+++ b/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
@@ -121,6 +121,10 @@ @implementation RTC_OBJC_TYPE (RTCPeerConnectionFactory) {
   std::unique_ptr<webrtc::Thread> _workerThread;
   std::unique_ptr<webrtc::Thread> _signalingThread;
   BOOL _hasStartedAecDump;
+  // RTCAudioDeviceModule は内部でネイティブ ADM を生成・保持する(scoped_refptr による所有)
+  // RTCPeerConnectionFactory は初期化時に RTCAudioDeviceModule から生ポインタを受け取る
+  // RTCAudioDeviceModule が破棄されると内部 ADM も破棄される
+  __weak RTC_OBJC_TYPE(RTCAudioDeviceModule)* _objcAudioDeviceModule;
 }
 
 @synthesize nativeFactory = _nativeFactory;
@@ -137,9 +141,6 @@ - (instancetype)init {
   dependencies.video_decoder_factory = webrtc::ObjCToNativeVideoDecoderFactory(
       [[RTC_OBJC_TYPE(RTCVideoDecoderFactoryH264) alloc] init]);
   dependencies.env = webrtc::CreateEnvironment();
-#ifdef WEBRTC_IOS
-  dependencies.adm = webrtc::CreateAudioDeviceModule(*dependencies.env);
-#endif
   return [self initWithMediaAndDependencies:dependencies];
 }
 
@@ -150,7 +151,8 @@ - (instancetype)init {
                                decoderFactory {
   return [self initWithEncoderFactory:encoderFactory
                        decoderFactory:decoderFactory
-                          audioDevice:nil];
+                          audioDevice:nil
+                     audioDeviceModule:nil];
 }
 
 - (instancetype)
@@ -158,8 +160,42 @@ - (instancetype)init {
         (nullable id<RTC_OBJC_TYPE(RTCVideoEncoderFactory)>)encoderFactory
             decoderFactory:(nullable id<RTC_OBJC_TYPE(RTCVideoDecoderFactory)>)
                                decoderFactory
-               audioDevice:
-                   (nullable id<RTC_OBJC_TYPE(RTCAudioDevice)>)audioDevice {
+                audioDevice:(nullable id<RTC_OBJC_TYPE(RTCAudioDevice)>)audioDevice {
+#ifdef HAVE_NO_MEDIA
+  return [self initWithNoMedia];
+#else
+  return [self initWithEncoderFactory:encoderFactory
+                       decoderFactory:decoderFactory
+                          audioDevice:audioDevice
+                     audioDeviceModule:nil];
+#endif
+}
+
+- (instancetype)
+    initWithEncoderFactory:
+        (nullable id<RTC_OBJC_TYPE(RTCVideoEncoderFactory)>)encoderFactory
+            decoderFactory:(nullable id<RTC_OBJC_TYPE(RTCVideoDecoderFactory)>)
+                               decoderFactory
+          audioDeviceModule:
+              (nullable RTC_OBJC_TYPE(RTCAudioDeviceModule)*)audioDeviceModule {
+#ifdef HAVE_NO_MEDIA
+  return [self initWithNoMedia];
+#else
+  return [self initWithEncoderFactory:encoderFactory
+                       decoderFactory:decoderFactory
+                          audioDevice:nil
+                     audioDeviceModule:audioDeviceModule];
+#endif
+}
+
+- (instancetype)
+    initWithEncoderFactory:
+        (nullable id<RTC_OBJC_TYPE(RTCVideoEncoderFactory)>)encoderFactory
+            decoderFactory:(nullable id<RTC_OBJC_TYPE(RTCVideoDecoderFactory)>)
+                               decoderFactory
+               audioDevice:(nullable id<RTC_OBJC_TYPE(RTCAudioDevice)>)audioDevice
+          audioDeviceModule:
+              (nullable RTC_OBJC_TYPE(RTCAudioDeviceModule)*)audioDeviceModule {
 #ifdef HAVE_NO_MEDIA
   return [self initWithNoMedia];
 #else
@@ -177,14 +213,25 @@ - (instancetype)init {
     dependencies.video_decoder_factory =
         webrtc::ObjCToNativeVideoDecoderFactory(decoderFactory);
   }
+#ifdef WEBRTC_IOS
+  // audioDevice と audioDeviceModule が両方指定されている場合、
+  // 元々の互換性を優先して audioDevice が指定されているものとする
   if (audioDevice) {
     dependencies.adm =
         webrtc::CreateAudioDeviceModule(*dependencies.env, audioDevice);
-#ifdef WEBRTC_IOS
+  } else if (audioDeviceModule) {
+    void* native_adm = [audioDeviceModule getNativeAudioDeviceModule];
+    auto adm_ptr = static_cast<webrtc::AudioDeviceModule*>(native_adm);
+    if (adm_ptr) {
+      dependencies.adm = adm_ptr;
+      _objcAudioDeviceModule = audioDeviceModule;
+    } else {
+      dependencies.adm = webrtc::CreateAudioDeviceModule(*dependencies.env);
+    }
   } else {
     dependencies.adm = webrtc::CreateAudioDeviceModule(*dependencies.env);
-#endif
   }
+#endif
   return [self initWithMediaAndDependencies:dependencies];
 #endif
 }
diff --git a/sdk/objc/components/audio/RTCAudioDeviceModule.h b/sdk/objc/components/audio/RTCAudioDeviceModule.h
new file mode 100644
index 0000000..0823504
--- /dev/null
+++ b/sdk/objc/components/audio/RTCAudioDeviceModule.h
@@ -0,0 +1,21 @@
+// iOS 用の AudioDeviceModule を生成し、pauseRecording()/resumeRecording() を公開するためのラッパー
+#import <Foundation/Foundation.h>
+
+#import "sdk/objc/base/RTCMacros.h"
+
+RTC_OBJC_EXPORT
+@interface RTC_OBJC_TYPE(RTCAudioDeviceModule) : NSObject
+
+// 内部で AudioDeviceModuleIOS を生成する
+- (instancetype)init;
+
+// ネイティブ ADM を取得する(所有権移動なし、未初期化なら nullptr)
+- (void *)getNativeAudioDeviceModule;
+
+// 録音を一時停止/再開する。成功時または状態が変わらない場合に YES を返す
+//
+// 一時停止状態で AudioDeviceIOS::StartRecording() が呼ばれた場合は ResumeRecording() にフォールバックされる
+- (BOOL)pauseRecording;
+- (BOOL)resumeRecording;
+
+@end
diff --git a/sdk/objc/components/audio/RTCAudioDeviceModule.mm b/sdk/objc/components/audio/RTCAudioDeviceModule.mm
new file mode 100644
index 0000000..b20c4a6
--- /dev/null
+++ b/sdk/objc/components/audio/RTCAudioDeviceModule.mm
@@ -0,0 +1,49 @@
+#import "RTCAudioDeviceModule.h"
+
+#include <arm_acle.h>
+
+#include "api/environment/environment_factory.h"
+#include "api/scoped_refptr.h"
+#include "sdk/objc/native/api/audio_device_module.h"
+#include "sdk/objc/native/src/audio/audio_device_module_ios.h"
+
+@interface RTC_OBJC_TYPE(RTCAudioDeviceModule) () {
+  // 所有権とライフサイクル管理対象のネイティブADM
+  webrtc::scoped_refptr<webrtc::AudioDeviceModule> _adm_owner;
+}
+@end
+
+@implementation RTC_OBJC_TYPE(RTCAudioDeviceModule)
+
+- (instancetype)init {
+  self = [super init];
+  if (self) {
+    auto env = webrtc::CreateEnvironment();
+    _adm_owner = webrtc::CreateAudioDeviceModule(env);
+  }
+  return self;
+}
+
+- (void *)getNativeAudioDeviceModule {
+  return _adm_owner.get();
+}
+
+- (BOOL)pauseRecording {
+  auto ptr =
+      static_cast<webrtc::ios_adm::AudioDeviceModuleIOS*>(_adm_owner.get());
+  if (!ptr) {
+    return NO;
+  }
+  return ptr->PauseRecording() == 0;
+}
+
+- (BOOL)resumeRecording {
+  auto ptr =
+      static_cast<webrtc::ios_adm::AudioDeviceModuleIOS*>(_adm_owner.get());
+  if (!ptr) {
+    return NO;
+  }
+  return ptr->ResumeRecording() == 0;
+}
+
+@end
diff --git a/sdk/objc/native/src/audio/audio_device_ios.h b/sdk/objc/native/src/audio/audio_device_ios.h
index d1788a3..b3d2b32 100644
--- a/sdk/objc/native/src/audio/audio_device_ios.h
+++ b/sdk/objc/native/src/audio/audio_device_ios.h
@@ -80,6 +80,8 @@ class AudioDeviceIOS : public AudioDeviceGeneric,
   bool Playing() const override;
 
   int32_t StartRecording() override;
+  int32_t PauseRecording();
+  int32_t ResumeRecording();
   int32_t StopRecording() override;
   bool Recording() const override;
 
@@ -292,6 +294,9 @@ class AudioDeviceIOS : public AudioDeviceGeneric,
   // Set to 1 when playout is active and 0 otherwise.
   std::atomic<int> playing_;
 
+  // Set to true when recording has been paused explicitly.
+  bool paused_recording_;
+
   // Set to true after successful call to Init(), false otherwise.
   bool initialized_ RTC_GUARDED_BY(thread_);
 
diff --git a/sdk/objc/native/src/audio/audio_device_ios.mm b/sdk/objc/native/src/audio/audio_device_ios.mm
index 021f08a..b60ca3c 100644
--- a/sdk/objc/native/src/audio/audio_device_ios.mm
+++ b/sdk/objc/native/src/audio/audio_device_ios.mm
@@ -110,6 +110,7 @@ static void LogDeviceInfo() {
       audio_unit_(nullptr),
       recording_(0),
       playing_(0),
+      paused_recording_(false),
       initialized_(false),
       audio_is_initialized_(false),
       is_interrupted_(false),
@@ -302,6 +303,10 @@ static void LogDeviceInfo() {
   LOGI() << "StartRecording";
   RTC_DCHECK_RUN_ON(thread_);
   RTC_DCHECK(audio_is_initialized_);
+  // 録音ポーズ中であれば ResumeRecording() にフォールスルーする
+  if (paused_recording_) {
+    return ResumeRecording();
+  }
   RTC_DCHECK(!recording_.load());
   RTC_DCHECK(audio_unit_);
   if (!audio_is_initialized_) {
@@ -330,9 +335,15 @@ static void LogDeviceInfo() {
 int32_t AudioDeviceIOS::StopRecording() {
   LOGI() << "StopRecording";
   RTC_DCHECK_RUN_ON(thread_);
-  if (!audio_is_initialized_ || !recording_.load()) {
+  if (!audio_is_initialized_)
+    return 0;
+  // 録音ポーズ中でも解放処理を実行するためのチェック
+  // 録音フラグが立っていない、かつ、録音ポーズ中でない -> 解放済みである、としてリターン
+  if (!recording_.load() && !paused_recording_) {
     return 0;
   }
+  // 実際の状態に関わらず録音ポーズフラグも解除しておく
+  paused_recording_ = false;
   if (!playing_.load()) {
     ShutdownPlayOrRecord();
   }
@@ -340,6 +351,52 @@ static void LogDeviceInfo() {
   return 0;
 }
 
+int32_t AudioDeviceIOS::PauseRecording() {
+  LOGI() << "PauseRecording";
+  RTC_DCHECK_RUN_ON(thread_);
+  if (paused_recording_) {
+    RTC_LOG(LS_VERBOSE) << "PauseRecording called while already paused";
+    return 0;
+  }
+  if (!audio_is_initialized_) {
+    RTC_LOG(LS_WARNING) << "PauseRecording called before audio is initialized";
+    return 0;
+  }
+  if (!recording_.load()) {
+    RTC_LOG(LS_WARNING) << "PauseRecording called while not recording";
+    return 0;
+  }
+  recording_.store(0, std::memory_order_release);
+  paused_recording_ = true;
+  return 0;
+}
+
+int32_t AudioDeviceIOS::ResumeRecording() {
+  LOGI() << "ResumeRecording";
+  RTC_DCHECK_RUN_ON(thread_);
+  if (!paused_recording_) {
+    return 0;
+  }
+  // InitRecording に失敗した場合は pause 状態の解除も recording_ の再立て直しも行えないため
+  // 上位にエラーを返す
+  if (!audio_is_initialized_) {
+    if (InitRecording() != 0) {
+      RTC_LOG(LS_ERROR) << "InitRecording failed during ResumeRecording";
+      paused_recording_ = false;
+      recording_.store(0, std::memory_order_release);
+      return -1;
+    }
+  }
+  paused_recording_ = false;
+  int32_t result = StartRecording();
+  if (result != 0) {
+    // Start に失敗したら再度 pause 状態に戻す
+    paused_recording_ = true;
+    recording_.store(0, std::memory_order_release);
+  }
+  return result;
+}
+
 bool AudioDeviceIOS::Recording() const {
   return recording_.load();
 }
diff --git a/sdk/objc/native/src/audio/audio_device_module_ios.h b/sdk/objc/native/src/audio/audio_device_module_ios.h
index 5ff5062..40626ae 100644
--- a/sdk/objc/native/src/audio/audio_device_module_ios.h
+++ b/sdk/objc/native/src/audio/audio_device_module_ios.h
@@ -76,6 +76,8 @@ class AudioDeviceModuleIOS : public AudioDeviceModule {
   int32_t StopPlayout() override;
   bool Playing() const override;
   int32_t StartRecording() override;
+  int32_t PauseRecording();
+  int32_t ResumeRecording();
   int32_t StopRecording() override;
   bool Recording() const override;
 
@@ -135,6 +137,7 @@ class AudioDeviceModuleIOS : public AudioDeviceModule {
   int GetPlayoutAudioParameters(AudioParameters* params) const override;
   int GetRecordAudioParameters(AudioParameters* params) const override;
 #endif  // WEBRTC_IOS
+
  private:
   void ReportError(ADMError error) const;
 
diff --git a/sdk/objc/native/src/audio/audio_device_module_ios.mm b/sdk/objc/native/src/audio/audio_device_module_ios.mm
index e2ea360..cb75318 100644
--- a/sdk/objc/native/src/audio/audio_device_module_ios.mm
+++ b/sdk/objc/native/src/audio/audio_device_module_ios.mm
@@ -55,14 +55,14 @@
   RTC_LOG(LS_INFO) << "iPhone Audio APIs will be utilized.";
 }
 
-int32_t AudioDeviceModuleIOS::AttachAudioBuffer() {
+AudioDeviceModuleIOS::~AudioDeviceModuleIOS() {
   RTC_DLOG(LS_INFO) << __FUNCTION__;
-  audio_device_->AttachAudioBuffer(audio_device_buffer_.get());
-  return 0;
 }
 
-AudioDeviceModuleIOS::~AudioDeviceModuleIOS() {
+int32_t AudioDeviceModuleIOS::AttachAudioBuffer() {
   RTC_DLOG(LS_INFO) << __FUNCTION__;
+  audio_device_->AttachAudioBuffer(audio_device_buffer_.get());
+  return 0;
 }
 
 void AudioDeviceModuleIOS::ReportError(ADMError error) const {
@@ -641,7 +641,9 @@
   if (Recording()) {
     return 0;
   }
-  audio_device_buffer_.get()->StartRecording();
+  if (audio_device_buffer_) {
+    audio_device_buffer_->StartRecording();
+  }
   int32_t result = audio_device_->StartRecording();
   if (result < 0) {
     ReportError(kRecordingStartFailed);
@@ -652,11 +654,41 @@
   return result;
 }
 
+int32_t AudioDeviceModuleIOS::PauseRecording() {
+  RTC_DLOG(LS_INFO) << __FUNCTION__;
+  CHECKinitialized_();
+  int32_t result = audio_device_->PauseRecording();
+  if (audio_device_buffer_) {
+    audio_device_buffer_->StopRecording();
+  }
+  if (result < 0) {
+    ReportError(kRecordingFailed);
+  }
+  RTC_DLOG(LS_INFO) << "output: " << result;
+  return result;
+}
+
+int32_t AudioDeviceModuleIOS::ResumeRecording() {
+  RTC_DLOG(LS_INFO) << __FUNCTION__;
+  CHECKinitialized_();
+  if (audio_device_buffer_) {
+    audio_device_buffer_->StartRecording();
+  }
+  int32_t result = audio_device_->ResumeRecording();
+  if (result < 0) {
+    ReportError(kRecordingFailed);
+  }
+  RTC_DLOG(LS_INFO) << "output: " << result;
+  return result;
+}
+
 int32_t AudioDeviceModuleIOS::StopRecording() {
   RTC_DLOG(LS_INFO) << __FUNCTION__;
   CHECKinitialized_();
   int32_t result = audio_device_->StopRecording();
-  audio_device_buffer_.get()->StopRecording();
+  if (audio_device_buffer_) {
+    audio_device_buffer_->StopRecording();
+  }
   if (result < 0) {
     ReportError(kRecordingFailed);
   }
