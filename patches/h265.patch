diff --git a/api/video_codecs/video_codec.cc b/api/video_codecs/video_codec.cc
index 39a345d699..5b53bbea15 100644
--- a/api/video_codecs/video_codec.cc
+++ b/api/video_codecs/video_codec.cc
@@ -53,6 +53,15 @@ bool VideoCodecH264::operator==(const VideoCodecH264& other) const {
           numberOfTemporalLayers == other.numberOfTemporalLayers);
 }
 
+bool VideoCodecH265::operator==(const VideoCodecH265& other) const {
+  return (frameDroppingOn == other.frameDroppingOn &&
+          keyFrameInterval == other.keyFrameInterval &&
+          vpsLen == other.vpsLen && spsLen == other.spsLen &&
+          ppsLen == other.ppsLen &&
+          (spsLen == 0 || memcmp(spsData, other.spsData, spsLen) == 0) &&
+          (ppsLen == 0 || memcmp(ppsData, other.ppsData, ppsLen) == 0));
+}
+
 VideoCodec::VideoCodec()
     : codecType(kVideoCodecGeneric),
       width(0),
@@ -103,6 +112,16 @@ const VideoCodecH264& VideoCodec::H264() const {
   return codec_specific_.H264;
 }
 
+VideoCodecH265* VideoCodec::H265() {
+  RTC_DCHECK_EQ(codecType, kVideoCodecH265);
+  return &codec_specific_.H265;
+}
+
+const VideoCodecH265& VideoCodec::H265() const {
+  RTC_DCHECK_EQ(codecType, kVideoCodecH265);
+  return codec_specific_.H265;
+}
+
 VideoCodecAV1* VideoCodec::AV1() {
   RTC_DCHECK_EQ(codecType, kVideoCodecAV1);
   return &codec_specific_.AV1;
diff --git a/api/video_codecs/video_codec.h b/api/video_codecs/video_codec.h
index a596af1528..2113857678 100644
--- a/api/video_codecs/video_codec.h
+++ b/api/video_codecs/video_codec.h
@@ -97,6 +97,21 @@ struct VideoCodecH264 {
   uint8_t numberOfTemporalLayers;
 };
 
+struct VideoCodecH265 {
+  bool operator==(const VideoCodecH265& other) const;
+  bool operator!=(const VideoCodecH265& other) const {
+    return !(*this == other);
+  }
+  bool frameDroppingOn;
+  int keyFrameInterval;
+  const uint8_t* vpsData;
+  size_t vpsLen;
+  const uint8_t* spsData;
+  size_t spsLen;
+  const uint8_t* ppsData;
+  size_t ppsLen;
+};
+
 struct VideoCodecAV1 {
   bool operator==(const VideoCodecAV1& other) const {
     return automatic_resize_on == other.automatic_resize_on;
@@ -116,6 +131,7 @@ union VideoCodecUnion {
   VideoCodecVP9 VP9;
   VideoCodecH264 H264;
   VideoCodecAV1 AV1;
+  VideoCodecH265 H265;
 };
 
 enum class VideoCodecMode { kRealtimeVideo, kScreensharing };
@@ -206,6 +222,8 @@ class RTC_EXPORT VideoCodec {
   const VideoCodecH264& H264() const;
   VideoCodecAV1* AV1();
   const VideoCodecAV1& AV1() const;
+  VideoCodecH265* H265();
+  const VideoCodecH265& H265() const;
 
  private:
   // TODO(hta): Consider replacing the union with a pointer type.
diff --git a/call/rtp_payload_params.cc b/call/rtp_payload_params.cc
index 4b63ebefb3..086a308d3f 100644
--- a/call/rtp_payload_params.cc
+++ b/call/rtp_payload_params.cc
@@ -96,6 +96,14 @@ void PopulateRtpWithCodecSpecifics(const CodecSpecificInfo& info,
           info.codecSpecific.H264.packetization_mode;
       return;
     }
+#ifdef RTC_ENABLE_H265
+    case kVideoCodecH265: {
+      auto& h265_header = rtp->video_type_header.emplace<RTPVideoHeaderH265>();
+      h265_header.packetization_mode =
+          info.codecSpecific.H265.packetization_mode;
+      return;
+    }
+#endif
     case kVideoCodecMultiplex:
     case kVideoCodecGeneric:
       rtp->codec = kVideoCodecGeneric;
diff --git a/common_video/h265/h265_pps_parser.cc b/common_video/h265/h265_pps_parser.cc
index 1cc9abd794..d8fa785b0e 100644
--- a/common_video/h265/h265_pps_parser.cc
+++ b/common_video/h265/h265_pps_parser.cc
@@ -90,6 +90,34 @@ bool H265PpsParser::ParsePpsIds(const uint8_t* data,
   return reader.Ok();
 }
 
+absl::optional<uint32_t> H265PpsParser::ParsePpsIdFromSliceSegmentLayerRbsp(
+    const uint8_t* data,
+    size_t length,
+    uint8_t nalu_type) {
+  std::vector<uint8_t> unpacked_buffer = H265::ParseRbsp(data, length);
+  BitstreamReader slice_reader(unpacked_buffer);
+
+  // first_slice_segment_in_pic_flag: u(1)
+  slice_reader.ConsumeBits(1);
+  if (!slice_reader.Ok()) {
+    return absl::nullopt;
+  }
+
+  if (nalu_type >= H265::NaluType::kBlaWLp &&
+      nalu_type <= H265::NaluType::kRsvIrapVcl23) {
+    // no_output_of_prior_pics_flag: u(1)
+    slice_reader.ConsumeBits(1);
+  }
+
+  // slice_pic_parameter_set_id: ue(v)
+  uint32_t slice_pic_parameter_set_id = slice_reader.ReadExponentialGolomb();
+  if (!slice_reader.Ok()) {
+    return absl::nullopt;
+  }
+
+  return slice_pic_parameter_set_id;
+}
+
 absl::optional<H265PpsParser::PpsState> H265PpsParser::ParseInternal(
     rtc::ArrayView<const uint8_t> buffer,
     const H265SpsParser::SpsState* sps) {
diff --git a/common_video/h265/h265_pps_parser.h b/common_video/h265/h265_pps_parser.h
index 625869d8d5..ea127ed396 100644
--- a/common_video/h265/h265_pps_parser.h
+++ b/common_video/h265/h265_pps_parser.h
@@ -51,6 +51,11 @@ class H265PpsParser {
                           uint32_t* pps_id,
                           uint32_t* sps_id);
 
+  static absl::optional<uint32_t> ParsePpsIdFromSliceSegmentLayerRbsp(
+      const uint8_t* data,
+      size_t length,
+      uint8_t nalu_type);
+
  protected:
   // Parse the PPS state, for a bit buffer where RBSP decoding has already been
   // performed.
diff --git a/modules/rtp_rtcp/BUILD.gn b/modules/rtp_rtcp/BUILD.gn
index b471c2fa76..7418449915 100644
--- a/modules/rtp_rtcp/BUILD.gn
+++ b/modules/rtp_rtcp/BUILD.gn
@@ -260,8 +260,10 @@ rtc_library("rtp_rtcp") {
 
   if (rtc_use_h265) {
     sources += [
-      "source/rtp_packetizer_h265.cc",
-      "source/rtp_packetizer_h265.h",
+      "source/rtp_format_h265.cc",
+      "source/rtp_format_h265.h",
+      "source/video_rtp_depacketizer_h265.cc",
+      "source/video_rtp_depacketizer_h265.h",
     ]
   }
 
diff --git a/modules/rtp_rtcp/source/create_video_rtp_depacketizer.cc b/modules/rtp_rtcp/source/create_video_rtp_depacketizer.cc
index 95db212bef..598a86d4ad 100644
--- a/modules/rtp_rtcp/source/create_video_rtp_depacketizer.cc
+++ b/modules/rtp_rtcp/source/create_video_rtp_depacketizer.cc
@@ -19,6 +19,9 @@
 #include "modules/rtp_rtcp/source/video_rtp_depacketizer_h264.h"
 #include "modules/rtp_rtcp/source/video_rtp_depacketizer_vp8.h"
 #include "modules/rtp_rtcp/source/video_rtp_depacketizer_vp9.h"
+#ifdef RTC_ENABLE_H265
+#include "modules/rtp_rtcp/source/video_rtp_depacketizer_h265.h"
+#endif
 
 namespace webrtc {
 
@@ -34,8 +37,11 @@ std::unique_ptr<VideoRtpDepacketizer> CreateVideoRtpDepacketizer(
     case kVideoCodecAV1:
       return std::make_unique<VideoRtpDepacketizerAv1>();
     case kVideoCodecH265:
-      // TODO(bugs.webrtc.org/13485): Implement VideoRtpDepacketizerH265.
+#ifdef RTC_ENABLE_H265
+      return std::make_unique<VideoRtpDepacketizerH265>();
+#else
       return nullptr;
+#endif
     case kVideoCodecGeneric:
     case kVideoCodecMultiplex:
       return std::make_unique<VideoRtpDepacketizerGeneric>();
diff --git a/modules/rtp_rtcp/source/rtp_format.cc b/modules/rtp_rtcp/source/rtp_format.cc
index c7534dee40..937a14c022 100644
--- a/modules/rtp_rtcp/source/rtp_format.cc
+++ b/modules/rtp_rtcp/source/rtp_format.cc
@@ -14,17 +14,23 @@
 
 #include "absl/types/variant.h"
 #include "modules/rtp_rtcp/source/rtp_format_h264.h"
+#ifdef RTC_ENABLE_H265
+#include "modules/rtp_rtcp/source/rtp_format_h265.h"
+#endif
 #include "modules/rtp_rtcp/source/rtp_format_video_generic.h"
 #include "modules/rtp_rtcp/source/rtp_format_vp8.h"
 #include "modules/rtp_rtcp/source/rtp_format_vp9.h"
 #include "modules/rtp_rtcp/source/rtp_packetizer_av1.h"
 #include "modules/video_coding/codecs/h264/include/h264_globals.h"
+#ifdef RTC_ENABLE_H265
+#include "modules/video_coding/codecs/h265/include/h265_globals.h"
+#endif
 #include "modules/video_coding/codecs/vp8/include/vp8_globals.h"
 #include "modules/video_coding/codecs/vp9/include/vp9_globals.h"
 #include "rtc_base/checks.h"
-#ifdef RTC_ENABLE_H265
-#include "modules/rtp_rtcp/source/rtp_packetizer_h265.h"
-#endif
+// #ifdef RTC_ENABLE_H265
+// #include "modules/rtp_rtcp/source/rtp_packetizer_h265.h"
+// #endif
 
 namespace webrtc {
 
@@ -46,6 +52,14 @@ std::unique_ptr<RtpPacketizer> RtpPacketizer::Create(
       return std::make_unique<RtpPacketizerH264>(payload, limits,
                                                  h264.packetization_mode);
     }
+#ifdef RTC_ENABLE_H265
+    case kVideoCodecH265: {
+      const auto& h265 =
+          absl::get<RTPVideoHeaderH265>(rtp_video_header.video_type_header);
+      return absl::make_unique<RtpPacketizerH265>(payload, limits,
+                                                  h265.packetization_mode);
+    }
+#endif
     case kVideoCodecVP8: {
       const auto& vp8 =
           absl::get<RTPVideoHeaderVP8>(rtp_video_header.video_type_header);
@@ -60,11 +74,11 @@ std::unique_ptr<RtpPacketizer> RtpPacketizer::Create(
       return std::make_unique<RtpPacketizerAv1>(
           payload, limits, rtp_video_header.frame_type,
           rtp_video_header.is_last_frame_in_picture);
-#ifdef RTC_ENABLE_H265
-    case kVideoCodecH265: {
-      return std::make_unique<RtpPacketizerH265>(payload, limits);
-    }
-#endif
+// #ifdef RTC_ENABLE_H265
+//     case kVideoCodecH265: {
+//       return std::make_unique<RtpPacketizerH265>(payload, limits);
+//     }
+// #endif
     default: {
       return std::make_unique<RtpPacketizerGeneric>(payload, limits,
                                                     rtp_video_header);
diff --git a/modules/rtp_rtcp/source/rtp_format_h265.cc b/modules/rtp_rtcp/source/rtp_format_h265.cc
new file mode 100644
index 0000000000..b354bb84f1
--- /dev/null
+++ b/modules/rtp_rtcp/source/rtp_format_h265.cc
@@ -0,0 +1,365 @@
+/*
+ *  Intel License
+ */
+
+#include "modules/rtp_rtcp/source/rtp_format_h265.h"
+
+#include <string.h>
+
+#include "absl/types/optional.h"
+#include "absl/types/variant.h"
+#include "common_video/h264/h264_common.h"
+#include "common_video/h265/h265_common.h"
+#include "common_video/h265/h265_pps_parser.h"
+#include "common_video/h265/h265_sps_parser.h"
+#include "common_video/h265/h265_vps_parser.h"
+#include "modules/include/module_common_types.h"
+#include "modules/rtp_rtcp/source/byte_io.h"
+#include "modules/rtp_rtcp/source/rtp_packet_to_send.h"
+#include "rtc_base/logging.h"
+
+using namespace rtc;
+
+namespace webrtc {
+namespace {
+
+enum NaluType {
+  kTrailN = 0,
+  kTrailR = 1,
+  kTsaN = 2,
+  kTsaR = 3,
+  kStsaN = 4,
+  kStsaR = 5,
+  kRadlN = 6,
+  kRadlR = 7,
+  kBlaWLp = 16,
+  kBlaWRadl = 17,
+  kBlaNLp = 18,
+  kIdrWRadl = 19,
+  kIdrNLp = 20,
+  kCra = 21,
+  kVps = 32,
+  kHevcSps = 33,
+  kHevcPps = 34,
+  kHevcAud = 35,
+  kPrefixSei = 39,
+  kSuffixSei = 40,
+  kHevcAp = 48,
+  kHevcFu = 49
+};
+
+/*
+   0                   1                   2                   3
+   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |    PayloadHdr (Type=49)       |   FU header   | DONL (cond)   |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|
+*/
+// Unlike H.264, HEVC NAL header is 2-bytes.
+static const size_t kHevcNalHeaderSize = 2;
+// H.265's FU is constructed of 2-byte payload header, and 1-byte FU header
+static const size_t kHevcFuHeaderSize = 1;
+static const size_t kHevcLengthFieldSize = 2;
+
+enum HevcNalHdrMasks {
+  kHevcFBit = 0x80,
+  kHevcTypeMask = 0x7E,
+  kHevcLayerIDHMask = 0x1,
+  kHevcLayerIDLMask = 0xF8,
+  kHevcTIDMask = 0x7,
+  kHevcTypeMaskN = 0x81,
+  kHevcTypeMaskInFuHeader = 0x3F
+};
+
+// Bit masks for FU headers.
+enum HevcFuDefs { kHevcSBit = 0x80, kHevcEBit = 0x40, kHevcFuTypeBit = 0x3F };
+
+}  // namespace
+
+RtpPacketizerH265::RtpPacketizerH265(rtc::ArrayView<const uint8_t> payload,
+                                     PayloadSizeLimits limits,
+                                     H265PacketizationMode packetization_mode)
+    : limits_(limits), num_packets_left_(0) {
+  // Guard against uninitialized memory in packetization_mode.
+  RTC_CHECK(packetization_mode == H265PacketizationMode::NonInterleaved ||
+            packetization_mode == H265PacketizationMode::SingleNalUnit);
+
+  for (const auto& nalu :
+       H264::FindNaluIndices(payload.data(), payload.size())) {
+    input_fragments_.push_back(
+        payload.subview(nalu.payload_start_offset, nalu.payload_size));
+  }
+
+  if (!GeneratePackets(packetization_mode)) {
+    // If failed to generate all the packets, discard already generated
+    // packets in case the caller would ignore return value and still try to
+    // call NextPacket().
+    num_packets_left_ = 0;
+    while (!packets_.empty()) {
+      packets_.pop();
+    }
+  }
+}
+
+RtpPacketizerH265::~RtpPacketizerH265() {}
+
+size_t RtpPacketizerH265::NumPackets() const {
+  return num_packets_left_;
+}
+
+bool RtpPacketizerH265::GeneratePackets(
+    H265PacketizationMode packetization_mode) {
+  // For HEVC we follow non-interleaved mode for the packetization,
+  // and don't support single-nalu mode at present.
+  for (size_t i = 0; i < input_fragments_.size();) {
+    int fragment_len = input_fragments_[i].size();
+    int single_packet_capacity = limits_.max_payload_len;
+    if (input_fragments_.size() == 1)
+      single_packet_capacity -= limits_.single_packet_reduction_len;
+    else if (i == 0)
+      single_packet_capacity -= limits_.first_packet_reduction_len;
+    else if (i + 1 == input_fragments_.size()) {
+      // Pretend that last fragment is larger instead of making last packet
+      // smaller.
+      single_packet_capacity -= limits_.last_packet_reduction_len;
+    }
+    if (fragment_len > single_packet_capacity) {
+      PacketizeFu(i);
+      ++i;
+    } else {
+      PacketizeSingleNalu(i);
+      ++i;
+    }
+  }
+  return true;
+}
+
+bool RtpPacketizerH265::PacketizeFu(size_t fragment_index) {
+  // Fragment payload into packets (FU).
+  // Strip out the original header and leave room for the FU header.
+  rtc::ArrayView<const uint8_t> fragment = input_fragments_[fragment_index];
+  PayloadSizeLimits limits = limits_;
+  limits.max_payload_len -= kHevcFuHeaderSize + kHevcNalHeaderSize;
+
+  // Update single/first/last packet reductions unless it is single/first/last
+  // fragment.
+  if (input_fragments_.size() != 1) {
+    // if this fragment is put into a single packet, it might still be the
+    // first or the last packet in the whole sequence of packets.
+    if (fragment_index == input_fragments_.size() - 1) {
+      limits.single_packet_reduction_len = limits_.last_packet_reduction_len;
+    } else if (fragment_index == 0) {
+      limits.single_packet_reduction_len = limits_.first_packet_reduction_len;
+    } else {
+      limits.single_packet_reduction_len = 0;
+    }
+  }
+  if (fragment_index != 0)
+    limits.first_packet_reduction_len = 0;
+  if (fragment_index != input_fragments_.size() - 1)
+    limits.last_packet_reduction_len = 0;
+
+  // Strip out the original header.
+  size_t payload_left = fragment.size() - kHevcNalHeaderSize;
+  int offset = kHevcNalHeaderSize;
+
+  std::vector<int> payload_sizes = SplitAboutEqually(payload_left, limits);
+  if (payload_sizes.empty())
+    return false;
+
+  for (size_t i = 0; i < payload_sizes.size(); ++i) {
+    int packet_length = payload_sizes[i];
+    RTC_CHECK_GT(packet_length, 0);
+    uint16_t header = (fragment[0] << 8) | fragment[1];
+    packets_.push(PacketUnit(fragment.subview(offset, packet_length),
+                             /*first_fragment=*/i == 0,
+                             /*last_fragment=*/i == payload_sizes.size() - 1,
+                             false, header));
+    offset += packet_length;
+    payload_left -= packet_length;
+  }
+  num_packets_left_ += payload_sizes.size();
+  RTC_CHECK_EQ(0, payload_left);
+  return true;
+}
+
+bool RtpPacketizerH265::PacketizeSingleNalu(size_t fragment_index) {
+  // Add a single NALU to the queue, no aggregation.
+  size_t payload_size_left = limits_.max_payload_len;
+  if (input_fragments_.size() == 1)
+    payload_size_left -= limits_.single_packet_reduction_len;
+  else if (fragment_index == 0)
+    payload_size_left -= limits_.first_packet_reduction_len;
+  else if (fragment_index + 1 == input_fragments_.size())
+    payload_size_left -= limits_.last_packet_reduction_len;
+  rtc::ArrayView<const uint8_t> fragment = input_fragments_[fragment_index];
+  if (payload_size_left < fragment.size()) {
+    RTC_LOG(LS_ERROR) << "Failed to fit a fragment to packet in SingleNalu "
+                         "packetization mode. Payload size left "
+                      << payload_size_left << ", fragment length "
+                      << fragment.size() << ", packet capacity "
+                      << limits_.max_payload_len;
+    return false;
+  }
+  RTC_CHECK_GT(fragment.size(), 0u);
+  packets_.push(PacketUnit(fragment, true /* first */, true /* last */,
+                           false /* aggregated */, fragment[0]));
+  ++num_packets_left_;
+  return true;
+}
+
+int RtpPacketizerH265::PacketizeAp(size_t fragment_index) {
+  // Aggregate fragments into one packet (STAP-A).
+  size_t payload_size_left = limits_.max_payload_len;
+  if (input_fragments_.size() == 1)
+    payload_size_left -= limits_.single_packet_reduction_len;
+  else if (fragment_index == 0)
+    payload_size_left -= limits_.first_packet_reduction_len;
+  int aggregated_fragments = 0;
+  size_t fragment_headers_length = 0;
+  rtc::ArrayView<const uint8_t> fragment = input_fragments_[fragment_index];
+  RTC_CHECK_GE(payload_size_left, fragment.size());
+  ++num_packets_left_;
+
+  auto payload_size_needed = [&] {
+    size_t fragment_size = fragment.size() + fragment_headers_length;
+    if (input_fragments_.size() == 1) {
+      // Single fragment, single packet, payload_size_left already adjusted
+      // with limits_.single_packet_reduction_len.
+      return fragment_size;
+    }
+    if (fragment_index == input_fragments_.size() - 1) {
+      // Last fragment, so StrapA might be the last packet.
+      return fragment_size + limits_.last_packet_reduction_len;
+    }
+    return fragment_size;
+  };
+
+  while (payload_size_left >= payload_size_needed()) {
+    RTC_CHECK_GT(fragment.size(), 0);
+    packets_.push(PacketUnit(fragment, aggregated_fragments == 0, false, true,
+                             fragment[0]));
+    payload_size_left -= fragment.size();
+    payload_size_left -= fragment_headers_length;
+
+    fragment_headers_length = kHevcLengthFieldSize;
+    // If we are going to try to aggregate more fragments into this packet
+    // we need to add the STAP-A NALU header and a length field for the first
+    // NALU of this packet.
+    if (aggregated_fragments == 0)
+      fragment_headers_length += kHevcNalHeaderSize + kHevcLengthFieldSize;
+    ++aggregated_fragments;
+
+    // Next fragment.
+    ++fragment_index;
+    if (fragment_index == input_fragments_.size())
+      break;
+    fragment = input_fragments_[fragment_index];
+  }
+  RTC_CHECK_GT(aggregated_fragments, 0);
+  packets_.back().last_fragment = true;
+  return fragment_index;
+}
+
+bool RtpPacketizerH265::NextPacket(RtpPacketToSend* rtp_packet) {
+  RTC_DCHECK(rtp_packet);
+
+  if (packets_.empty()) {
+    return false;
+  }
+
+  PacketUnit packet = packets_.front();
+
+  if (packet.first_fragment && packet.last_fragment) {
+    // Single NAL unit packet.
+    size_t bytes_to_send = packet.source_fragment.size();
+    uint8_t* buffer = rtp_packet->AllocatePayload(bytes_to_send);
+    memcpy(buffer, packet.source_fragment.data(), bytes_to_send);
+    packets_.pop();
+    input_fragments_.pop_front();
+  } else if (packet.aggregated) {
+    bool is_last_packet = num_packets_left_ == 1;
+    NextAggregatePacket(rtp_packet, is_last_packet);
+  } else {
+    NextFragmentPacket(rtp_packet);
+  }
+  rtp_packet->SetMarker(packets_.empty());
+  --num_packets_left_;
+  return true;
+}
+
+void RtpPacketizerH265::NextAggregatePacket(RtpPacketToSend* rtp_packet,
+                                            bool last) {
+  size_t payload_capacity = rtp_packet->FreeCapacity();
+  RTC_CHECK_GE(payload_capacity, kHevcNalHeaderSize);
+  uint8_t* buffer = rtp_packet->AllocatePayload(payload_capacity);
+
+  PacketUnit* packet = &packets_.front();
+  RTC_CHECK(packet->first_fragment);
+  uint8_t payload_hdr_h = packet->header >> 8;
+  uint8_t payload_hdr_l = packet->header & 0xFF;
+  uint8_t layer_id_h = payload_hdr_h & kHevcLayerIDHMask;
+
+  payload_hdr_h =
+      (payload_hdr_h & kHevcTypeMaskN) | (kHevcAp << 1) | layer_id_h;
+
+  buffer[0] = payload_hdr_h;
+  buffer[1] = payload_hdr_l;
+  int index = kHevcNalHeaderSize;
+  bool is_last_fragment = packet->last_fragment;
+  while (packet->aggregated) {
+    // Add NAL unit length field.
+    rtc::ArrayView<const uint8_t> fragment = packet->source_fragment;
+    ByteWriter<uint16_t>::WriteBigEndian(&buffer[index], fragment.size());
+    index += kHevcLengthFieldSize;
+    // Add NAL unit.
+    memcpy(&buffer[index], fragment.data(), fragment.size());
+    index += fragment.size();
+    packets_.pop();
+    input_fragments_.pop_front();
+    if (is_last_fragment)
+      break;
+    packet = &packets_.front();
+    is_last_fragment = packet->last_fragment;
+  }
+  RTC_CHECK(is_last_fragment);
+  rtp_packet->SetPayloadSize(index);
+}
+
+void RtpPacketizerH265::NextFragmentPacket(RtpPacketToSend* rtp_packet) {
+  PacketUnit* packet = &packets_.front();
+  // NAL unit fragmented over multiple packets (FU).
+  // We do not send original NALU header, so it will be replaced by the
+  // PayloadHdr of the first packet.
+  uint8_t payload_hdr_h =
+      packet->header >> 8;  // 1-bit F, 6-bit type, 1-bit layerID highest-bit
+  uint8_t payload_hdr_l = packet->header & 0xFF;
+  uint8_t layer_id_h = payload_hdr_h & kHevcLayerIDHMask;
+  uint8_t fu_header = 0;
+  // S | E |6 bit type.
+  fu_header |= (packet->first_fragment ? kHevcSBit : 0);
+  fu_header |= (packet->last_fragment ? kHevcEBit : 0);
+  uint8_t type = (payload_hdr_h & kHevcTypeMask) >> 1;
+  fu_header |= type;
+  // Now update payload_hdr_h with FU type.
+  payload_hdr_h =
+      (payload_hdr_h & kHevcTypeMaskN) | (kHevcFu << 1) | layer_id_h;
+  rtc::ArrayView<const uint8_t> fragment = packet->source_fragment;
+  uint8_t* buffer = rtp_packet->AllocatePayload(
+      kHevcFuHeaderSize + kHevcNalHeaderSize + fragment.size());
+  RTC_CHECK(buffer);
+  buffer[0] = payload_hdr_h;
+  buffer[1] = payload_hdr_l;
+  buffer[2] = fu_header;
+
+  if (packet->last_fragment) {
+    memcpy(buffer + kHevcFuHeaderSize + kHevcNalHeaderSize, fragment.data(),
+           fragment.size());
+  } else {
+    memcpy(buffer + kHevcFuHeaderSize + kHevcNalHeaderSize, fragment.data(),
+           fragment.size());
+ }
+  packets_.pop();
+}
+
+}  // namespace webrtc
diff --git a/modules/rtp_rtcp/source/rtp_format_h265.h b/modules/rtp_rtcp/source/rtp_format_h265.h
new file mode 100644
index 0000000000..164895e1ae
--- /dev/null
+++ b/modules/rtp_rtcp/source/rtp_format_h265.h
@@ -0,0 +1,107 @@
+/*
+ *  Copyright (c) 2020 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#ifndef WEBRTC_MODULES_RTP_RTCP_SOURCE_RTP_FORMAT_H265_H_
+#define WEBRTC_MODULES_RTP_RTCP_SOURCE_RTP_FORMAT_H265_H_
+
+#include <memory>
+#include <queue>
+#include <string>
+
+#include "api/array_view.h"
+#include "modules/include/module_common_types.h"
+#include "modules/rtp_rtcp/source/rtp_format.h"
+#include "modules/rtp_rtcp/source/rtp_packet_to_send.h"
+#include "modules/video_coding/codecs/h265/include/h265_globals.h"
+#include "rtc_base/buffer.h"
+
+namespace webrtc {
+
+class RtpPacketizerH265 : public RtpPacketizer {
+ public:
+  // Initialize with payload from encoder.
+  // The payload_data must be exactly one encoded H.265 frame.
+  RtpPacketizerH265(rtc::ArrayView<const uint8_t> payload,
+                    PayloadSizeLimits limits,
+                    H265PacketizationMode packetization_mode);
+
+  ~RtpPacketizerH265() override;
+
+  RtpPacketizerH265(const RtpPacketizerH265&) = delete;
+  RtpPacketizerH265& operator=(const RtpPacketizerH265&) = delete;
+
+  size_t NumPackets() const override;
+
+  // Get the next payload with H.265 payload header.
+  // buffer is a pointer to where the output will be written.
+  // bytes_to_send is an output variable that will contain number of bytes
+  // written to buffer. The parameter last_packet is true for the last packet of
+  // the frame, false otherwise (i.e., call the function again to get the
+  // next packet).
+  // Returns true on success or false if there was no payload to packetize.
+  bool NextPacket(RtpPacketToSend* rtp_packet) override;
+
+ private:
+  struct Packet {
+    Packet(size_t offset,
+           size_t size,
+           bool first_fragment,
+           bool last_fragment,
+           bool aggregated,
+           uint16_t header)
+        : offset(offset),
+          size(size),
+          first_fragment(first_fragment),
+          last_fragment(last_fragment),
+          aggregated(aggregated),
+          header(header) {}
+
+    size_t offset;
+    size_t size;
+    bool first_fragment;
+    bool last_fragment;
+    bool aggregated;
+    uint16_t header;  // Different from H264
+  };
+  struct PacketUnit {
+    PacketUnit(rtc::ArrayView<const uint8_t> source_fragment,
+               bool first_fragment,
+               bool last_fragment,
+               bool aggregated,
+               uint16_t header)
+        : source_fragment(source_fragment),
+          first_fragment(first_fragment),
+          last_fragment(last_fragment),
+          aggregated(aggregated),
+          header(header) {}
+
+    rtc::ArrayView<const uint8_t> source_fragment;
+    bool first_fragment;
+    bool last_fragment;
+    bool aggregated;
+    uint16_t header;
+  };
+  typedef std::queue<Packet> PacketQueue;
+  std::deque<rtc::ArrayView<const uint8_t>> input_fragments_;
+  std::queue<PacketUnit> packets_;
+
+  bool GeneratePackets(H265PacketizationMode packetization_mode);
+  bool PacketizeFu(size_t fragment_index);
+  int PacketizeAp(size_t fragment_index);
+  bool PacketizeSingleNalu(size_t fragment_index);
+
+  void NextAggregatePacket(RtpPacketToSend* rtp_packet, bool last);
+  void NextFragmentPacket(RtpPacketToSend* rtp_packet);
+
+  const PayloadSizeLimits limits_;
+  size_t num_packets_left_;
+};
+}  // namespace webrtc
+#endif  // WEBRTC_MODULES_RTP_RTCP_SOURCE_RTP_FORMAT_H265_H_
diff --git a/modules/rtp_rtcp/source/rtp_sender_video.cc b/modules/rtp_rtcp/source/rtp_sender_video.cc
index 4d819a80a9..745696140d 100644
--- a/modules/rtp_rtcp/source/rtp_sender_video.cc
+++ b/modules/rtp_rtcp/source/rtp_sender_video.cc
@@ -805,6 +805,9 @@ uint8_t RTPSenderVideo::GetTemporalId(const RTPVideoHeader& header) {
       return vp9.temporal_idx;
     }
     uint8_t operator()(const RTPVideoHeaderH264&) { return kNoTemporalIdx; }
+#ifdef RTC_ENABLE_H265
+    uint8_t operator()(const RTPVideoHeaderH265&) { return kNoTemporalIdx; }
+#endif
     uint8_t operator()(const RTPVideoHeaderLegacyGeneric&) {
       return kNoTemporalIdx;
     }
diff --git a/modules/rtp_rtcp/source/rtp_video_header.h b/modules/rtp_rtcp/source/rtp_video_header.h
index 3100d4d1e7..b34b888909 100644
--- a/modules/rtp_rtcp/source/rtp_video_header.h
+++ b/modules/rtp_rtcp/source/rtp_video_header.h
@@ -26,6 +26,9 @@
 #include "api/video/video_rotation.h"
 #include "api/video/video_timing.h"
 #include "modules/video_coding/codecs/h264/include/h264_globals.h"
+#ifdef RTC_ENABLE_H265
+#include "modules/video_coding/codecs/h265/include/h265_globals.h"
+#endif
 #include "modules/video_coding/codecs/vp8/include/vp8_globals.h"
 #include "modules/video_coding/codecs/vp9/include/vp9_globals.h"
 
@@ -41,6 +44,9 @@ using RTPVideoTypeHeader = absl::variant<absl::monostate,
                                          RTPVideoHeaderVP8,
                                          RTPVideoHeaderVP9,
                                          RTPVideoHeaderH264,
+#ifdef RTC_ENABLE_H265
+                                         RTPVideoHeaderH265,
+#endif
                                          RTPVideoHeaderLegacyGeneric>;
 
 struct RTPVideoHeader {
diff --git a/modules/rtp_rtcp/source/video_rtp_depacketizer_h265.cc b/modules/rtp_rtcp/source/video_rtp_depacketizer_h265.cc
new file mode 100644
index 0000000000..5d102f5c0b
--- /dev/null
+++ b/modules/rtp_rtcp/source/video_rtp_depacketizer_h265.cc
@@ -0,0 +1,354 @@
+/*
+ *  Copyright (c) 2020 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#ifdef RTC_ENABLE_H265
+#include "modules/rtp_rtcp/source/video_rtp_depacketizer_h265.h"
+
+#include <cstddef>
+#include <cstdint>
+#include <utility>
+#include <vector>
+
+#include "absl/base/macros.h"
+#include "absl/types/optional.h"
+#include "absl/types/variant.h"
+#include "common_video/h264/h264_common.h"
+#include "common_video/h265/h265_common.h"
+#include "common_video/h265/h265_pps_parser.h"
+#include "common_video/h265/h265_sps_parser.h"
+#include "common_video/h265/h265_vps_parser.h"
+#include "modules/rtp_rtcp/source/byte_io.h"
+#include "modules/rtp_rtcp/source/video_rtp_depacketizer.h"
+#include "modules/video_coding/codecs/h265/include/h265_globals.h"
+#include "rtc_base/checks.h"
+#include "rtc_base/copy_on_write_buffer.h"
+#include "rtc_base/logging.h"
+
+namespace webrtc {
+namespace {
+
+enum NaluType {
+  kTrailN = 0,
+  kTrailR = 1,
+  kTsaN = 2,
+  kTsaR = 3,
+  kStsaN = 4,
+  kStsaR = 5,
+  kRadlN = 6,
+  kRadlR = 7,
+  kBlaWLp = 16,
+  kBlaWRadl = 17,
+  kBlaNLp = 18,
+  kIdrWRadl = 19,
+  kIdrNLp = 20,
+  kCra = 21,
+  kVps = 32,
+  kHevcSps = 33,
+  kHevcPps = 34,
+  kHevcAud = 35
+};
+
+/*
+   0                   1                   2                   3
+   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |    PayloadHdr (Type=49)       |   FU header   | DONL (cond)   |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|
+*/
+// Unlike H.264, HEVC NAL header is 2-bytes.
+static const size_t kHevcNalHeaderSize = 2;
+// H.265's FU is constructed of 2-byte payload header, and 1-byte FU header
+static const size_t kHevcFuHeaderSize = 1;
+static const size_t kHevcLengthFieldSize = 2;
+static const size_t kHevcApHeaderSize =
+    kHevcNalHeaderSize + kHevcLengthFieldSize;
+
+enum HevcNalHdrMasks {
+  kHevcFBit = 0x80,
+  kHevcTypeMask = 0x7E,
+  kHevcLayerIDHMask = 0x1,
+  kHevcLayerIDLMask = 0xF8,
+  kHevcTIDMask = 0x7,
+  kHevcTypeMaskN = 0x81,
+  kHevcTypeMaskInFuHeader = 0x3F
+};
+
+// Bit masks for FU headers.
+enum HevcFuDefs { kHevcSBit = 0x80, kHevcEBit = 0x40, kHevcFuTypeBit = 0x3F };
+
+// TODO(pbos): Avoid parsing this here as well as inside the jitter buffer.
+bool ParseApStartOffsets(const uint8_t* nalu_ptr,
+                         size_t length_remaining,
+                         std::vector<size_t>* offsets) {
+  size_t offset = 0;
+  while (length_remaining > 0) {
+    // Buffer doesn't contain room for additional nalu length.
+    if (length_remaining < sizeof(uint16_t))
+      return false;
+    uint16_t nalu_size = ByteReader<uint16_t>::ReadBigEndian(nalu_ptr);
+    nalu_ptr += sizeof(uint16_t);
+    length_remaining -= sizeof(uint16_t);
+    if (nalu_size > length_remaining)
+      return false;
+    nalu_ptr += nalu_size;
+    length_remaining -= nalu_size;
+
+    offsets->push_back(offset + kHevcApHeaderSize);
+    offset += kHevcLengthFieldSize + nalu_size;
+  }
+  return true;
+}
+
+absl::optional<VideoRtpDepacketizer::ParsedRtpPayload> ProcessApOrSingleNalu(
+    rtc::CopyOnWriteBuffer rtp_payload) {
+  const uint8_t* const payload_data = rtp_payload.cdata();
+  absl::optional<VideoRtpDepacketizer::ParsedRtpPayload> parsed_payload(
+      absl::in_place);
+  parsed_payload->video_payload = rtp_payload;
+  parsed_payload->video_header.width = 0;
+  parsed_payload->video_header.height = 0;
+  parsed_payload->video_header.codec = kVideoCodecH265;
+  parsed_payload->video_header.is_first_packet_in_frame = true;
+  auto& h265_header = parsed_payload->video_header.video_type_header
+                          .emplace<RTPVideoHeaderH265>();
+
+  const uint8_t* nalu_start = payload_data + kHevcNalHeaderSize;
+  const size_t nalu_length = rtp_payload.size() - kHevcNalHeaderSize;
+  uint8_t nal_type = (payload_data[0] & kHevcTypeMask) >> 1;
+  std::vector<size_t> nalu_start_offsets;
+  if (nal_type == H265::NaluType::kAp) {
+    // Skip the StapA header (StapA NAL type + length).
+    if (rtp_payload.size() <= kHevcApHeaderSize) {
+      RTC_LOG(LS_ERROR) << "AP header truncated.";
+      return absl::nullopt;
+    }
+
+    if (!ParseApStartOffsets(nalu_start, nalu_length, &nalu_start_offsets)) {
+      RTC_LOG(LS_ERROR) << "AP packet with incorrect NALU packet lengths.";
+      return absl::nullopt;
+    }
+
+    h265_header.packetization_type = kH265AP;
+    // nal_type = (payload_data[kHevcApHeaderSize] & kHevcTypeMask) >> 1;
+  } else {
+    h265_header.packetization_type = kH265SingleNalu;
+    nalu_start_offsets.push_back(0);
+  }
+  h265_header.nalu_type = nal_type;
+  parsed_payload->video_header.frame_type = VideoFrameType::kVideoFrameDelta;
+
+  nalu_start_offsets.push_back(rtp_payload.size() +
+                               kHevcLengthFieldSize);  // End offset.
+  for (size_t i = 0; i < nalu_start_offsets.size() - 1; ++i) {
+    size_t start_offset = nalu_start_offsets[i];
+    // End offset is actually start offset for next unit, excluding length field
+    // so remove that from this units length.
+    size_t end_offset = nalu_start_offsets[i + 1] - kHevcLengthFieldSize;
+    if (end_offset - start_offset < kHevcNalHeaderSize) {  // Same as H.264.
+      RTC_LOG(LS_ERROR) << "AP packet too short";
+      return absl::nullopt;
+    }
+
+    H265NaluInfo nalu;
+    nalu.type = (payload_data[start_offset] & kHevcTypeMask) >> 1;
+    nalu.vps_id = -1;
+    nalu.sps_id = -1;
+    nalu.pps_id = -1;
+    start_offset += kHevcNalHeaderSize;
+    switch (nalu.type) {
+      case H265::NaluType::kVps: {
+        absl::optional<H265VpsParser::VpsState> vps = H265VpsParser::ParseVps(
+            &payload_data[start_offset], end_offset - start_offset);
+        if (vps) {
+          nalu.vps_id = vps->id;
+        } else {
+          RTC_LOG(LS_WARNING) << "Failed to parse VPS id from VPS slice.";
+        }
+        break;
+      }
+      case H265::NaluType::kSps: {
+        // TODO: Check if VUI is present in SPS and if it needs to be modified
+        // to avoid excessive decoder latency.
+
+        // Copy any previous data first (likely just the first header).
+        std::unique_ptr<rtc::Buffer> output_buffer(new rtc::Buffer());
+        if (start_offset)
+          output_buffer->AppendData(payload_data, start_offset);
+
+        absl::optional<H265SpsParser::SpsState> sps = H265SpsParser::ParseSps(
+            &payload_data[start_offset], end_offset - start_offset);
+
+        if (sps) {
+          parsed_payload->video_header.width = sps->width;
+          parsed_payload->video_header.height = sps->height;
+          nalu.sps_id = sps->sps_id;
+          nalu.vps_id = sps->vps_id;
+        } else {
+          RTC_LOG(LS_WARNING)
+              << "Failed to parse SPS and VPS id from SPS slice.";
+        }
+        parsed_payload->video_header.frame_type =
+            VideoFrameType::kVideoFrameKey;
+        break;
+      }
+      case H265::NaluType::kPps: {
+        uint32_t pps_id;
+        uint32_t sps_id;
+        if (H265PpsParser::ParsePpsIds(&payload_data[start_offset],
+                                       end_offset - start_offset, &pps_id,
+                                       &sps_id)) {
+          nalu.pps_id = pps_id;
+          nalu.sps_id = sps_id;
+        } else {
+          RTC_LOG(LS_WARNING)
+              << "Failed to parse PPS id and SPS id from PPS slice.";
+        }
+        break;
+      }
+      case H265::NaluType::kIdrWRadl:
+      case H265::NaluType::kIdrNLp:
+      case H265::NaluType::kCra:
+        parsed_payload->video_header.frame_type =
+            VideoFrameType::kVideoFrameKey;
+        ABSL_FALLTHROUGH_INTENDED;
+      case H265::NaluType::kTrailN:
+      case H265::NaluType::kTrailR: {
+        absl::optional<uint32_t> pps_id =
+            H265PpsParser::ParsePpsIdFromSliceSegmentLayerRbsp(
+                &payload_data[start_offset], end_offset - start_offset,
+                nalu.type);
+        if (pps_id) {
+          nalu.pps_id = *pps_id;
+        } else {
+          RTC_LOG(LS_WARNING) << "Failed to parse PPS id from slice of type: "
+                              << static_cast<int>(nalu.type);
+        }
+        break;
+      }
+      // Slices below don't contain SPS or PPS ids.
+      case H265::NaluType::kAud:
+      case H265::NaluType::kTsaN:
+      case H265::NaluType::kTsaR:
+      case H265::NaluType::kStsaN:
+      case H265::NaluType::kStsaR:
+      case H265::NaluType::kRadlN:
+      case H265::NaluType::kRadlR:
+      case H265::NaluType::kBlaWLp:
+      case H265::NaluType::kBlaWRadl:
+      case H265::NaluType::kPrefixSei:
+      case H265::NaluType::kSuffixSei:
+        break;
+      case H265::NaluType::kAp:
+      case H265::NaluType::kFu:
+        RTC_LOG(LS_WARNING) << "Unexpected AP or FU received.";
+        return absl::nullopt;
+    }
+
+    if (h265_header.nalus_length == kMaxNalusPerPacket) {
+      RTC_LOG(LS_WARNING)
+          << "Received packet containing more than " << kMaxNalusPerPacket
+          << " NAL units. Will not keep track sps and pps ids for all of them.";
+    } else {
+      h265_header.nalus[h265_header.nalus_length++] = nalu;
+    }
+  }
+  return parsed_payload;
+}
+
+absl::optional<VideoRtpDepacketizer::ParsedRtpPayload> ParseFuNalu(
+    rtc::CopyOnWriteBuffer rtp_payload) {
+  if (rtp_payload.size() < kHevcFuHeaderSize + kHevcNalHeaderSize) {
+    RTC_LOG(LS_ERROR) << "FU-A NAL units truncated.";
+    return absl::nullopt;
+  }
+  absl::optional<VideoRtpDepacketizer::ParsedRtpPayload> parsed_payload(
+      absl::in_place);
+
+  uint8_t f = rtp_payload.cdata()[0] & kHevcFBit;
+  uint8_t layer_id_h = rtp_payload.cdata()[0] & kHevcLayerIDHMask;
+  uint8_t layer_id_l_unshifted = rtp_payload.cdata()[1] & kHevcLayerIDLMask;
+  uint8_t tid = rtp_payload.cdata()[1] & kHevcTIDMask;
+
+  uint8_t original_nal_type = rtp_payload.cdata()[2] & kHevcTypeMaskInFuHeader;
+  bool first_fragment = rtp_payload.cdata()[2] & kHevcSBit;
+  H265NaluInfo nalu;
+  nalu.type = original_nal_type;
+  nalu.vps_id = -1;
+  nalu.sps_id = -1;
+  nalu.pps_id = -1;
+  if (first_fragment) {
+    absl::optional<uint32_t> pps_id =
+        H265PpsParser::ParsePpsIdFromSliceSegmentLayerRbsp(
+            rtp_payload.cdata() + kHevcNalHeaderSize + kHevcFuHeaderSize,
+            rtp_payload.size() - kHevcFuHeaderSize, nalu.type);
+    if (pps_id) {
+      nalu.pps_id = *pps_id;
+    } else {
+      RTC_LOG(LS_WARNING)
+          << "Failed to parse PPS from first fragment of FU NAL "
+             "unit with original type: "
+          << static_cast<int>(nalu.type);
+    }
+    rtp_payload = rtp_payload.Slice(1, rtp_payload.size() - 1);
+    rtp_payload.MutableData()[0] = f | original_nal_type << 1 | layer_id_h;
+    rtp_payload.MutableData()[1] = layer_id_l_unshifted | tid;
+    parsed_payload->video_payload = std::move(rtp_payload);
+  } else {
+    parsed_payload->video_payload = rtp_payload.Slice(
+        kHevcNalHeaderSize + kHevcFuHeaderSize,
+        rtp_payload.size() - kHevcNalHeaderSize - kHevcFuHeaderSize);
+  }
+
+  if (original_nal_type == H265::NaluType::kIdrWRadl ||
+      original_nal_type == H265::NaluType::kIdrNLp ||
+      original_nal_type == H265::NaluType::kCra) {
+    parsed_payload->video_header.frame_type = VideoFrameType::kVideoFrameKey;
+  } else {
+    parsed_payload->video_header.frame_type = VideoFrameType::kVideoFrameDelta;
+  }
+  parsed_payload->video_header.width = 0;
+  parsed_payload->video_header.height = 0;
+  parsed_payload->video_header.codec = kVideoCodecH265;
+  parsed_payload->video_header.is_first_packet_in_frame = first_fragment;
+  auto& h265_header = parsed_payload->video_header.video_type_header
+                          .emplace<RTPVideoHeaderH265>();
+  h265_header.packetization_type = kH265FU;
+  h265_header.nalu_type = original_nal_type;
+  if (first_fragment) {
+    h265_header.nalus[h265_header.nalus_length] = nalu;
+    h265_header.nalus_length = 1;
+  }
+  return parsed_payload;
+}
+
+}  // namespace
+
+absl::optional<VideoRtpDepacketizer::ParsedRtpPayload>
+VideoRtpDepacketizerH265::Parse(rtc::CopyOnWriteBuffer rtp_payload) {
+  if (rtp_payload.size() == 0) {
+    RTC_LOG(LS_ERROR) << "Empty payload.";
+    return absl::nullopt;
+  }
+
+  uint8_t nal_type = (rtp_payload.cdata()[0] & kHevcTypeMask) >> 1;
+
+  if (nal_type == H265::NaluType::kFu) {
+    // Fragmented NAL units (FU-A).
+    return ParseFuNalu(std::move(rtp_payload));
+  } else {
+    // We handle STAP-A and single NALU's the same way here. The jitter buffer
+    // will depacketize the STAP-A into NAL units later.
+    // TODO(sprang): Parse STAP-A offsets here and store in fragmentation vec.
+    return ProcessApOrSingleNalu(std::move(rtp_payload));
+  }
+}
+
+}  // namespace webrtc
+#endif
diff --git a/modules/rtp_rtcp/source/video_rtp_depacketizer_h265.h b/modules/rtp_rtcp/source/video_rtp_depacketizer_h265.h
new file mode 100644
index 0000000000..4ae90cb6fe
--- /dev/null
+++ b/modules/rtp_rtcp/source/video_rtp_depacketizer_h265.h
@@ -0,0 +1,28 @@
+/*
+ *  Copyright (c) 2020 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#ifndef MODULES_RTP_RTCP_SOURCE_VIDEO_RTP_DEPACKETIZER_H265_H_
+#define MODULES_RTP_RTCP_SOURCE_VIDEO_RTP_DEPACKETIZER_H265_H_
+
+#include "absl/types/optional.h"
+#include "modules/rtp_rtcp/source/video_rtp_depacketizer.h"
+#include "rtc_base/copy_on_write_buffer.h"
+
+namespace webrtc {
+class VideoRtpDepacketizerH265 : public VideoRtpDepacketizer {
+ public:
+  ~VideoRtpDepacketizerH265() override = default;
+
+  absl::optional<ParsedRtpPayload> Parse(
+      rtc::CopyOnWriteBuffer rtp_payload) override;
+};
+}  // namespace webrtc
+
+#endif  // MODULES_RTP_RTCP_SOURCE_VIDEO_RTP_DEPACKETIZER_H265_H_
diff --git a/modules/video_coding/BUILD.gn b/modules/video_coding/BUILD.gn
index 738d3d4edf..969fb554a5 100644
--- a/modules/video_coding/BUILD.gn
+++ b/modules/video_coding/BUILD.gn
@@ -200,6 +200,13 @@ rtc_library("video_coding") {
     "video_receiver2.h",
   ]
 
+  if (rtc_use_h265) {
+    sources += [
+      "h265_vps_sps_pps_tracker.cc",
+      "h265_vps_sps_pps_tracker.h",
+    ]
+  }
+
   deps = [
     ":codec_globals_headers",
     ":encoded_frame",
diff --git a/modules/video_coding/codecs/h265/include/h265_globals.h b/modules/video_coding/codecs/h265/include/h265_globals.h
new file mode 100644
index 0000000000..df577722aa
--- /dev/null
+++ b/modules/video_coding/codecs/h265/include/h265_globals.h
@@ -0,0 +1,58 @@
+/*
+ *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+// This file contains codec dependent definitions that are needed in
+// order to compile the WebRTC codebase, even if this codec is not used.
+
+#ifndef MODULES_VIDEO_CODING_CODECS_H265_INCLUDE_H265_GLOBALS_H_
+#define MODULES_VIDEO_CODING_CODECS_H265_INCLUDE_H265_GLOBALS_H_
+
+#include "modules/video_coding/codecs/h264/include/h264_globals.h"
+
+namespace webrtc {
+
+// The packetization types that we support: single, aggregated, and fragmented.
+enum H265PacketizationTypes {
+  kH265SingleNalu,  // This packet contains a single NAL unit.
+  kH265AP,          // This packet contains aggregation Packet.
+                    // If this packet has an associated NAL unit type,
+                    // it'll be for the first such aggregated packet.
+  kH265FU,          // This packet contains a FU (fragmentation
+                    // unit) packet, meaning it is a part of a frame
+                    // that was too large to fit into a single packet.
+};
+
+struct H265NaluInfo {
+  uint8_t type;
+  int vps_id;
+  int sps_id;
+  int pps_id;
+};
+
+enum class H265PacketizationMode {
+  NonInterleaved = 0,  // Mode 1 - STAP-A, FU-A is allowed
+  SingleNalUnit        // Mode 0 - only single NALU allowed
+};
+
+struct RTPVideoHeaderH265 {
+  // The NAL unit type. If this is a header for a fragmented packet, it's the
+  // NAL unit type of the original data. If this is the header for an aggregated
+  // packet, it's the NAL unit type of the first NAL unit in the packet.
+  uint8_t nalu_type;
+  H265PacketizationTypes packetization_type;
+  H265NaluInfo nalus[kMaxNalusPerPacket];
+  size_t nalus_length;
+  // The packetization type of this buffer - single, aggregated or fragmented.
+  H265PacketizationMode packetization_mode;
+};
+
+}  // namespace webrtc
+
+#endif  // MODULES_VIDEO_CODING_CODECS_H265_INCLUDE_H265_GLOBALS_H_
diff --git a/modules/video_coding/h265_vps_sps_pps_tracker.cc b/modules/video_coding/h265_vps_sps_pps_tracker.cc
new file mode 100644
index 0000000000..e09f800af7
--- /dev/null
+++ b/modules/video_coding/h265_vps_sps_pps_tracker.cc
@@ -0,0 +1,229 @@
+/*
+ *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+#include "modules/video_coding/h265_vps_sps_pps_tracker.h"
+
+#include <memory>
+#include <string>
+#include <utility>
+
+#include "absl/types/variant.h"
+#include "common_video/h264/h264_common.h"
+#include "common_video/h265/h265_common.h"
+#include "common_video/h265/h265_pps_parser.h"
+#include "common_video/h265/h265_sps_parser.h"
+#include "common_video/h265/h265_vps_parser.h"
+#include "modules/video_coding/codecs/h264/include/h264_globals.h"
+#include "modules/video_coding/codecs/h265/include/h265_globals.h"
+#include "modules/video_coding/packet_buffer.h"
+#include "modules/rtp_rtcp/source/frame_object.h"
+#include "rtc_base/checks.h"
+#include "rtc_base/logging.h"
+
+namespace webrtc {
+namespace video_coding {
+
+namespace {
+const uint8_t start_code_h265[] = {0, 0, 0, 1};
+}  // namespace
+
+H265VpsSpsPpsTracker::FixedBitstream H265VpsSpsPpsTracker::CopyAndFixBitstream(
+    rtc::ArrayView<const uint8_t> bitstream,
+    RTPVideoHeader* video_header) {
+  RTC_DCHECK(video_header);
+  RTC_DCHECK(video_header->codec == kVideoCodecH265);
+
+  auto& h265_header =
+      absl::get<RTPVideoHeaderH265>(video_header->video_type_header);
+
+  bool append_vps_sps_pps = false;
+  auto vps = vps_data_.end();
+  auto sps = sps_data_.end();
+  auto pps = pps_data_.end();
+
+  for (size_t i = 0; i < h265_header.nalus_length; ++i) {
+    const H265NaluInfo& nalu = h265_header.nalus[i];
+    switch (nalu.type) {
+      case H265::NaluType::kVps: {
+        vps_data_[nalu.vps_id].size = 0;
+        break;
+      }
+      case H265::NaluType::kSps: {
+        sps_data_[nalu.sps_id].vps_id = nalu.vps_id;
+        sps_data_[nalu.sps_id].width = video_header->width;
+        sps_data_[nalu.sps_id].height = video_header->height;
+        break;
+      }
+      case H265::NaluType::kPps: {
+        pps_data_[nalu.pps_id].sps_id = nalu.sps_id;
+        break;
+      }
+      case H265::NaluType::kIdrWRadl:
+      case H265::NaluType::kIdrNLp:
+      case H265::NaluType::kCra: {
+        // If this is the first packet of an IDR, make sure we have the required
+        // SPS/PPS and also calculate how much extra space we need in the buffer
+        // to prepend the SPS/PPS to the bitstream with start codes.
+        if (video_header->is_first_packet_in_frame) {
+          if (nalu.pps_id == -1) {
+            RTC_LOG(LS_WARNING) << "No PPS id in IDR nalu.";
+            return {kRequestKeyframe};
+          }
+
+          pps = pps_data_.find(nalu.pps_id);
+          if (pps == pps_data_.end()) {
+            RTC_LOG(LS_WARNING)
+                << "No PPS with id " << nalu.pps_id << " received";
+            return {kRequestKeyframe};
+          }
+
+          sps = sps_data_.find(pps->second.sps_id);
+          if (sps == sps_data_.end()) {
+            RTC_LOG(LS_WARNING)
+                << "No SPS with id << " << pps->second.sps_id << " received";
+            return {kRequestKeyframe};
+          }
+
+          vps = vps_data_.find(sps->second.vps_id);
+          if (vps == vps_data_.end()) {
+            RTC_LOG(LS_WARNING)
+                << "No VPS with id " << sps->second.vps_id << " received";
+            return {kRequestKeyframe};
+          }
+
+          // Since the first packet of every keyframe should have its width and
+          // height set we set it here in the case of it being supplied out of
+          // band.
+          video_header->width = sps->second.width;
+          video_header->height = sps->second.height;
+
+          // If the VPS/SPS/PPS was supplied out of band then we will have saved
+          // the actual bitstream in |data|.
+          // This branch is not verified.
+          if (vps->second.data && sps->second.data && pps->second.data) {
+            RTC_DCHECK_GT(vps->second.size, 0);
+            RTC_DCHECK_GT(sps->second.size, 0);
+            RTC_DCHECK_GT(pps->second.size, 0);
+            append_vps_sps_pps = true;
+          }
+        }
+        break;
+      }
+      default:
+        break;
+    }
+  }
+
+  RTC_CHECK(!append_vps_sps_pps ||
+            (sps != sps_data_.end() && pps != pps_data_.end()));
+
+  // Calculate how much space we need for the rest of the bitstream.
+  size_t required_size = 0;
+
+  if (append_vps_sps_pps) {
+    required_size += vps->second.size + sizeof(start_code_h265);
+    required_size += sps->second.size + sizeof(start_code_h265);
+    required_size += pps->second.size + sizeof(start_code_h265);
+  }
+
+  if (h265_header.packetization_type == kH265AP) {
+    const uint8_t* nalu_ptr = bitstream.data() + 1;
+    while (nalu_ptr < bitstream.data() + bitstream.size()) {
+      RTC_DCHECK(video_header->is_first_packet_in_frame);
+      required_size += sizeof(start_code_h265);
+
+      // The first two bytes describe the length of a segment.
+      uint16_t segment_length = nalu_ptr[0] << 8 | nalu_ptr[1];
+      nalu_ptr += 2;
+
+      required_size += segment_length;
+      nalu_ptr += segment_length;
+    }
+  } else {
+    // TODO: in h.264 this is "h264_header.nalus_length > 0"
+    if (video_header->is_first_packet_in_frame)
+      required_size += sizeof(start_code_h265);
+    required_size += bitstream.size();
+  }
+
+  // Then we copy to the new buffer.
+  H265VpsSpsPpsTracker::FixedBitstream fixed;
+  fixed.bitstream.EnsureCapacity(required_size);
+
+  if (append_vps_sps_pps) {
+    // Insert VPS.
+    fixed.bitstream.AppendData(start_code_h265);
+    fixed.bitstream.AppendData(vps->second.data.get(), vps->second.size);
+
+    // Insert SPS.
+    fixed.bitstream.AppendData(start_code_h265);
+    fixed.bitstream.AppendData(sps->second.data.get(), sps->second.size);
+
+    // Insert PPS.
+    fixed.bitstream.AppendData(start_code_h265);
+    fixed.bitstream.AppendData(pps->second.data.get(), pps->second.size);
+
+    // Update codec header to reflect the newly added SPS and PPS.
+    H265NaluInfo vps_info;
+    vps_info.type = H265::NaluType::kVps;
+    vps_info.vps_id = vps->first;
+    vps_info.sps_id = -1;
+    vps_info.pps_id = -1;
+    H265NaluInfo sps_info;
+    sps_info.type = H265::NaluType::kSps;
+    sps_info.vps_id = vps->first;
+    sps_info.sps_id = sps->first;
+    sps_info.pps_id = -1;
+    H265NaluInfo pps_info;
+    pps_info.type = H265::NaluType::kPps;
+    pps_info.vps_id = vps->first;
+    pps_info.sps_id = sps->first;
+    pps_info.pps_id = pps->first;
+    if (h265_header.nalus_length + 3 <= kMaxNalusPerPacket) {
+      h265_header.nalus[h265_header.nalus_length++] = vps_info;
+      h265_header.nalus[h265_header.nalus_length++] = sps_info;
+      h265_header.nalus[h265_header.nalus_length++] = pps_info;
+    } else {
+      RTC_LOG(LS_WARNING) << "Not enough space in H.265 codec header to insert "
+                             "SPS/PPS provided out-of-band.";
+    }
+  }
+
+  // Copy the rest of the bitstream and insert start codes.
+  if (h265_header.packetization_type == kH265AP) {
+    const uint8_t* nalu_ptr = bitstream.data() + 1;
+    while (nalu_ptr < bitstream.data() + bitstream.size()) {
+      fixed.bitstream.AppendData(start_code_h265);
+
+      // The first two bytes describe the length of a segment.
+      uint16_t segment_length = nalu_ptr[0] << 8 | nalu_ptr[1];
+      nalu_ptr += 2;
+
+      size_t copy_end = nalu_ptr - bitstream.data() + segment_length;
+      if (copy_end > bitstream.size()) {
+        return {kDrop};
+      }
+
+      fixed.bitstream.AppendData(nalu_ptr, segment_length);
+      nalu_ptr += segment_length;
+    }
+  } else {
+    // For h.264 it is "h264_header.nalus_length > 0"
+    if (video_header->is_first_packet_in_frame) {
+      fixed.bitstream.AppendData(start_code_h265);
+    }
+    fixed.bitstream.AppendData(bitstream.data(), bitstream.size());
+  }
+
+  fixed.action = kInsert;
+  return fixed;
+}
+
+}  // namespace video_coding
+}  // namespace webrtc
diff --git a/modules/video_coding/h265_vps_sps_pps_tracker.h b/modules/video_coding/h265_vps_sps_pps_tracker.h
new file mode 100644
index 0000000000..5f53faab1a
--- /dev/null
+++ b/modules/video_coding/h265_vps_sps_pps_tracker.h
@@ -0,0 +1,66 @@
+/*
+ *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#ifndef MODULES_VIDEO_CODING_H265_VPS_SPS_PPS_TRACKER_H_
+#define MODULES_VIDEO_CODING_H265_VPS_SPS_PPS_TRACKER_H_
+
+#include <cstddef>
+#include <cstdint>
+#include <map>
+#include <memory>
+#include <vector>
+
+#include "api/array_view.h"
+#include "modules/rtp_rtcp/source/rtp_video_header.h"
+#include "rtc_base/copy_on_write_buffer.h"
+
+namespace webrtc {
+namespace video_coding {
+
+class H265VpsSpsPpsTracker {
+ public:
+  enum PacketAction { kInsert, kDrop, kRequestKeyframe };
+  struct FixedBitstream {
+    PacketAction action;
+    rtc::CopyOnWriteBuffer bitstream;
+  };
+
+  FixedBitstream CopyAndFixBitstream(rtc::ArrayView<const uint8_t> bitstream,
+                                     RTPVideoHeader* video_header);
+
+ private:
+  struct VpsInfo {
+    size_t size = 0;
+    std::unique_ptr<uint8_t[]> data;
+  };
+
+  struct PpsInfo {
+    int sps_id = -1;
+    size_t size = 0;
+    std::unique_ptr<uint8_t[]> data;
+  };
+
+  struct SpsInfo {
+    int vps_id = -1;
+    size_t size = 0;
+    int width = -1;
+    int height = -1;
+    std::unique_ptr<uint8_t[]> data;
+  };
+
+  std::map<uint32_t, VpsInfo> vps_data_;
+  std::map<uint32_t, PpsInfo> pps_data_;
+  std::map<uint32_t, SpsInfo> sps_data_;
+};
+
+}  // namespace video_coding
+}  // namespace webrtc
+
+#endif  // MODULES_VIDEO_CODING_H265_SPS_PPS_TRACKER_H_
diff --git a/modules/video_coding/include/video_codec_interface.h b/modules/video_coding/include/video_codec_interface.h
index 987e1b623e..7a5cab75b0 100644
--- a/modules/video_coding/include/video_codec_interface.h
+++ b/modules/video_coding/include/video_codec_interface.h
@@ -20,6 +20,9 @@
 #include "api/video_codecs/video_encoder.h"
 #include "common_video/generic_frame_descriptor/generic_frame_info.h"
 #include "modules/video_coding/codecs/h264/include/h264_globals.h"
+#ifdef RTC_ENABLE_H265
+#include "modules/video_coding/codecs/h265/include/h265_globals.h"
+#endif
 #include "modules/video_coding/codecs/vp9/include/vp9_globals.h"
 #include "modules/video_coding/include/video_error_codes.h"
 #include "rtc_base/system/rtc_export.h"
@@ -96,10 +99,20 @@ static_assert(std::is_trivial_v<CodecSpecificInfoH264> &&
                   std::is_standard_layout_v<CodecSpecificInfoH264>,
               "");
 
+#ifdef RTC_ENABLE_H265
+struct CodecSpecificInfoH265 {
+  H265PacketizationMode packetization_mode;
+  bool idr_frame;
+};
+#endif
+
 union CodecSpecificInfoUnion {
   CodecSpecificInfoVP8 VP8;
   CodecSpecificInfoVP9 VP9;
   CodecSpecificInfoH264 H264;
+#ifdef RTC_ENABLE_H265
+  CodecSpecificInfoH265 H265;
+#endif
 };
 static_assert(std::is_trivial_v<CodecSpecificInfoUnion> &&
                   std::is_standard_layout_v<CodecSpecificInfoUnion>,
               "");
diff --git a/modules/video_coding/packet_buffer.cc b/modules/video_coding/packet_buffer.cc
index 420a200ba9..635f90a748 100644
--- a/modules/video_coding/packet_buffer.cc
+++ b/modules/video_coding/packet_buffer.cc
@@ -23,10 +23,16 @@
 #include "api/rtp_packet_info.h"
 #include "api/video/video_frame_type.h"
 #include "common_video/h264/h264_common.h"
+#ifdef RTC_ENABLE_H265
+#include "common_video/h265/h265_common.h"
+#endif
 #include "modules/rtp_rtcp/source/rtp_header_extensions.h"
 #include "modules/rtp_rtcp/source/rtp_packet_received.h"
 #include "modules/rtp_rtcp/source/rtp_video_header.h"
 #include "modules/video_coding/codecs/h264/include/h264_globals.h"
+#ifdef RTC_ENABLE_H265
+#include "modules/video_coding/codecs/h265/include/h265_globals.h"
+#endif
 #include "rtc_base/checks.h"
 #include "rtc_base/logging.h"
 #include "rtc_base/numerics/mod_ops.h"
@@ -270,13 +276,22 @@ std::vector<std::unique_ptr<PacketBuffer::Packet>> PacketBuffer::FindFrames(
       bool has_h264_pps = false;
       bool has_h264_idr = false;
       bool is_h264_keyframe = false;
+      bool is_h265_descriptor = false;
+#ifdef RTC_ENABLE_H265
+      is_h265_descriptor =
+          (buffer_[start_index]->codec() == kVideoCodecH265) && !is_generic;
+      bool has_h265_sps = false;
+      bool has_h265_pps = false;
+      bool has_h265_idr = false;
+      bool is_h265_keyframe = false;
+#endif
       int idr_width = -1;
       int idr_height = -1;
       bool full_frame_found = false;
       while (true) {
         ++tested_packets;
 
-        if (!is_h264_descriptor) {
+        if (!is_h264_descriptor && !is_h265_descriptor) {
           if (buffer_[start_index] == nullptr ||
               buffer_[start_index]->is_first_packet_in_frame()) {
             full_frame_found = buffer_[start_index] != nullptr;
@@ -314,6 +329,34 @@ std::vector<std::unique_ptr<PacketBuffer::Packet>> PacketBuffer::FindFrames(
             }
           }
         }
+#ifdef RTC_ENABLE_H265
+        if (is_h265_descriptor && !is_h265_keyframe) {
+          const auto* h265_header = absl::get_if<RTPVideoHeaderH265>(
+              &buffer_[start_index]->video_header.video_type_header);
+          if (!h265_header || h265_header->nalus_length >= kMaxNalusPerPacket)
+            return found_frames;
+          for (size_t j = 0; j < h265_header->nalus_length; ++j) {
+            if (h265_header->nalus[j].type == H265::NaluType::kSps) {
+              has_h265_sps = true;
+            } else if (h265_header->nalus[j].type == H265::NaluType::kPps) {
+              has_h265_pps = true;
+            } else if (h265_header->nalus[j].type ==
+                           H265::NaluType::kIdrWRadl ||
+                       h265_header->nalus[j].type == H265::NaluType::kIdrNLp ||
+                       h265_header->nalus[j].type == H265::NaluType::kCra) {
+              has_h265_idr = true;
+            }
+          }
+          if ((has_h265_sps && has_h265_pps) || has_h265_idr) {
+            is_h265_keyframe = true;
+            if (buffer_[start_index]->width() > 0 &&
+                buffer_[start_index]->height() > 0) {
+              idr_width = buffer_[start_index]->width();
+              idr_height = buffer_[start_index]->height();
+            }
+          }
+        }
+#endif
 
         if (tested_packets == buffer_.size())
           break;
@@ -326,7 +369,7 @@ std::vector<std::unique_ptr<PacketBuffer::Packet>> PacketBuffer::FindFrames(
         // the timestamp of that packet is the same as this one. This may cause
         // the PacketBuffer to hand out incomplete frames.
         // See: https://bugs.chromium.org/p/webrtc/issues/detail?id=7106
-        if (is_h264_descriptor &&
+        if ((is_h264_descriptor || is_h265_descriptor) &&
             (buffer_[start_index] == nullptr ||
              buffer_[start_index]->timestamp != frame_timestamp)) {
           break;
@@ -373,7 +416,44 @@ std::vector<std::unique_ptr<PacketBuffer::Packet>> PacketBuffer::FindFrames(
         }
       }
 
-      if (is_h264_descriptor || full_frame_found) {
+#ifdef RTC_ENABLE_H265
+      if (is_h265_descriptor) {
+        // Warn if this is an unsafe frame.
+        if (has_h265_idr && (!has_h265_sps || !has_h265_pps)) {
+          RTC_LOG(LS_WARNING)
+              << "Received H.265-IDR frame "
+              << "(SPS: " << has_h265_sps << ", PPS: " << has_h265_pps << "). "
+              << "Treating as delta frame since "
+              << "WebRTC-SpsPpsIdrIsH265Keyframe is always enabled.";
+        }
+
+        // Now that we have decided whether to treat this frame as a key frame
+        // or delta frame in the frame buffer, we update the field that
+        // determines if the RtpFrameObject is a key frame or delta frame.
+        const size_t first_packet_index = start_seq_num % buffer_.size();
+        if (is_h265_keyframe) {
+          buffer_[first_packet_index]->video_header.frame_type =
+              VideoFrameType::kVideoFrameKey;
+          if (idr_width > 0 && idr_height > 0) {
+            // IDR frame was finalized and we have the correct resolution for
+            // IDR; update first packet to have same resolution as IDR.
+            buffer_[first_packet_index]->video_header.width = idr_width;
+            buffer_[first_packet_index]->video_header.height = idr_height;
+          }
+        } else {
+          buffer_[first_packet_index]->video_header.frame_type =
+              VideoFrameType::kVideoFrameDelta;
+        }
+
+        // If this is not a key frame, make sure there are no gaps in the
+        // packet sequence numbers up until this point.
+        if (!is_h265_keyframe && missing_packets_.upper_bound(start_seq_num) !=
+                                     missing_packets_.begin()) {
+          return found_frames;
+        }
+      }
+#endif
+      if (is_h264_descriptor || is_h265_descriptor || full_frame_found) {
         const uint16_t end_seq_num = seq_num + 1;
         // Use uint16_t type to handle sequence number wrap around case.
         uint16_t num_packets = end_seq_num - start_seq_num;
diff --git a/rtc_base/experiments/min_video_bitrate_experiment.cc b/rtc_base/experiments/min_video_bitrate_experiment.cc
index f9e7613a15..607dc47704 100644
--- a/rtc_base/experiments/min_video_bitrate_experiment.cc
+++ b/rtc_base/experiments/min_video_bitrate_experiment.cc
@@ -95,7 +95,9 @@ absl::optional<DataRate> GetExperimentalMinVideoBitrate(VideoCodecType type) {
       case kVideoCodecVP8:
         return min_bitrate_vp8.GetOptional();
       case kVideoCodecH265:
-      //  TODO(bugs.webrtc.org/13485): Use VP9 bitrate limits for now.
+#ifdef RTC_ENABLE_H265
+        return min_bitrate_h264.GetOptional();
+#endif
       case kVideoCodecVP9:
         return min_bitrate_vp9.GetOptional();
       case kVideoCodecAV1:
diff --git a/video/config/video_encoder_config.cc b/video/config/video_encoder_config.cc
index 84442aeddf..44f2dac910 100644
--- a/video/config/video_encoder_config.cc
+++ b/video/config/video_encoder_config.cc
@@ -97,12 +97,23 @@ void VideoEncoderConfig::EncoderSpecificSettings::FillEncoderSpecificSettings(
     FillVideoCodecVp9(codec->VP9());
   } else if (codec->codecType == kVideoCodecAV1) {
     FillVideoCodecAv1(codec->AV1());
+#ifdef RTC_ENABLE_H265
+  } else if (codec->codecType == kVideoCodecH265) {
+    FillVideoCodecH265(codec->H265());
+#endif
   } else {
     RTC_DCHECK_NOTREACHED()
         << "Encoder specifics set/used for unknown codec type.";
   }
 }
 
+#ifdef RTC_ENABLE_H265
+void VideoEncoderConfig::EncoderSpecificSettings::FillVideoCodecH265(
+    VideoCodecH265* h265_settings) const {
+  RTC_DCHECK_NOTREACHED();
+}
+#endif
+
 void VideoEncoderConfig::EncoderSpecificSettings::FillVideoCodecVp8(
     VideoCodecVP8* vp8_settings) const {
   RTC_DCHECK_NOTREACHED();
diff --git a/video/config/video_encoder_config.h b/video/config/video_encoder_config.h
index cb0644a7fd..7e1f986a84 100644
--- a/video/config/video_encoder_config.h
+++ b/video/config/video_encoder_config.h
@@ -97,6 +97,9 @@ class VideoEncoderConfig {
     // directly.
     void FillEncoderSpecificSettings(VideoCodec* codec_struct) const;
 
+#ifdef RTC_ENABLE_H265
+    virtual void FillVideoCodecH265(VideoCodecH265* h265_settings) const;
+#endif
     virtual void FillVideoCodecVp8(VideoCodecVP8* vp8_settings) const;
     virtual void FillVideoCodecVp9(VideoCodecVP9* vp9_settings) const;
     virtual void FillVideoCodecAv1(VideoCodecAV1* av1_settings) const;
diff --git a/video/rtp_video_stream_receiver2.cc b/video/rtp_video_stream_receiver2.cc
index badb942cd4..d032643287 100644
--- a/video/rtp_video_stream_receiver2.cc
+++ b/video/rtp_video_stream_receiver2.cc
@@ -39,6 +39,9 @@
 #include "modules/rtp_rtcp/source/video_rtp_depacketizer_raw.h"
 #include "modules/video_coding/h264_sprop_parameter_sets.h"
 #include "modules/video_coding/h264_sps_pps_tracker.h"
+#ifdef RTC_ENABLE_H265
+#include "modules/video_coding/h265_vps_sps_pps_tracker.h"
+#endif
 #include "modules/video_coding/nack_requester.h"
 #include "modules/video_coding/packet_buffer.h"
 #include "rtc_base/checks.h"
@@ -690,7 +693,33 @@ bool RtpVideoStreamReceiver2::OnReceivedPayloadData(
         packet->video_payload = std::move(fixed.bitstream);
         break;
     }
+#ifdef RTC_ENABLE_H265
+  } else if (packet->codec() == kVideoCodecH265) {
+    // Only when we start to receive packets will we know what payload type
+    // that will be used. When we know the payload type insert the correct
+    // sps/pps into the tracker.
+    if (packet->payload_type != last_payload_type_) {
+      last_payload_type_ = packet->payload_type;
+      InsertSpsPpsIntoTracker(packet->payload_type);
+    }
 
+    video_coding::H265VpsSpsPpsTracker::FixedBitstream fixed =
+        h265_tracker_.CopyAndFixBitstream(
+            rtc::MakeArrayView(codec_payload.cdata(), codec_payload.size()),
+            &packet->video_header);
+
+    switch (fixed.action) {
+      case video_coding::H265VpsSpsPpsTracker::kRequestKeyframe:
+        rtcp_feedback_buffer_.RequestKeyFrame();
+        rtcp_feedback_buffer_.SendBufferedRtcpFeedback();
+        ABSL_FALLTHROUGH_INTENDED;
+      case video_coding::H265VpsSpsPpsTracker::kDrop:
+        return false;
+      case video_coding::H265VpsSpsPpsTracker::kInsert:
+        packet->video_payload = std::move(fixed.bitstream);
+        break;
+    }
+#endif
   } else {
     packet->video_payload = std::move(codec_payload);
   }
diff --git a/video/rtp_video_stream_receiver2.h b/video/rtp_video_stream_receiver2.h
index 0178355262..c41bf3bf82 100644
--- a/video/rtp_video_stream_receiver2.h
+++ b/video/rtp_video_stream_receiver2.h
@@ -39,6 +39,9 @@
 #include "modules/rtp_rtcp/source/rtp_video_stream_receiver_frame_transformer_delegate.h"
 #include "modules/rtp_rtcp/source/video_rtp_depacketizer.h"
 #include "modules/video_coding/h264_sps_pps_tracker.h"
+#ifdef RTC_ENABLE_H265
+#include "modules/video_coding/h265_vps_sps_pps_tracker.h"
+#endif
 #include "modules/video_coding/loss_notification_controller.h"
 #include "modules/video_coding/nack_requester.h"
 #include "modules/video_coding/packet_buffer.h"
@@ -390,6 +393,10 @@ class RtpVideoStreamReceiver2 : public LossNotificationSender,
   std::map<uint8_t, std::unique_ptr<VideoRtpDepacketizer>> payload_type_map_
       RTC_GUARDED_BY(packet_sequence_checker_);
 
+#ifdef RTC_ENABLE_H265
+  video_coding::H265VpsSpsPpsTracker h265_tracker_;
+#endif
+
   // TODO(johan): Remove pt_codec_params_ once
   // https://bugs.chromium.org/p/webrtc/issues/detail?id=6883 is resolved.
   // Maps a payload type to a map of out-of-band supplied codec parameters.
diff --git a/video/video_stream_encoder.cc b/video/video_stream_encoder.cc
index 84f6108807..0ef2180472 100644
--- a/video/video_stream_encoder.cc
+++ b/video/video_stream_encoder.cc
@@ -136,8 +136,14 @@ bool RequiresEncoderReset(const VideoCodec& prev_send_codec,
       }
       break;
     case kVideoCodecH265:
-      // TODO(bugs.webrtc.org/13485): Implement new send codec H265
+#ifdef RTC_ENABLE_H265
+      if (new_send_codec.H265() != prev_send_codec.H265()) {
+        return true;
+      }
+      break;
+#else
       [[fallthrough]];
+#endif
     default:
       break;
   }
diff --git a/webrtc.gni b/webrtc.gni
index 5a1c43c888..bc136ea127 100644
--- a/webrtc.gni
+++ b/webrtc.gni
@@ -190,7 +190,7 @@ declare_args() {
       proprietary_codecs && !is_android && !is_ios && !(is_win && !is_clang)
 
   # Enable to use H265
-  rtc_use_h265 = proprietary_codecs
+  rtc_use_h265 = true
 
   # Enable this flag to make webrtc::Mutex be implemented by absl::Mutex.
   rtc_use_absl_mutex = false
